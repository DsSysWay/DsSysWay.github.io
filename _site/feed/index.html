<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>ftom</title>
    <link href="http://192.168.73.128:4000/feed/" rel="self" />
    <link href="http://dssysway.github.io" />
    <lastBuildDate>2018-04-22T05:18:22-05:00</lastBuildDate>
    <webMaster>linuxserverlover@gmail.com</webMaster>
    
    <item>
      <title>2017年终总结.</title>
      <link href="http://192.168.73.128:4000/2018/04/22/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93_2017/"/>
      <pubDate>2018-04-22T00:00:00-05:00</pubDate>
      <author>ftom</author>
      <guid>http://192.168.73.128:4000/2018/04/22/年终总结_2017</guid>
      <content:encoded><![CDATA[<p>2018 已经过去一大半了, 关于去年的年终总结一直
没有选择写. 因为一直在等待职级答辩的结果，这个也是
2017年我的主要目标之一。直到尘埃落定之后才选择空余的
时间来处理这个事情。</p>

<p>16年12月底的时候，老婆怀孕了，我们在过年的时候一起
定的家庭目标主要有以下几个：</p>

<ul>
<li>老婆顺利把娃健健康康的生下来。</li>
<li>把买房欠丈母娘的首付控制在某个额度下</li>
<li>顺利升3</li>
<li>家庭年收入维持去年的水平。
在家庭收入这块我们做了最严格的核算，结果发现维持去年
的水平家庭到年底还是负债状态，哈哈。</li>
</ul>


<hr />

<p>17年是最忙碌的一年，以至于任何聚餐聚会我都推掉了，
理由只有一个，加班，我在加班。加班中。。
年初的时候加入的新的游戏项目，当时在前部门被打了
2星，危机感爆棚，感觉像吃了颗定时炸弹，而且面临一年后的
升3答辩，如果依旧停留在老项目，很可能因为清闲无事导致没有材料可答。部门里有些同
事已经试了好几次均告失败。最大的原因就是非新项目，维护
老代码。所以答辩起来比较尴尬。</p>

<p>新项目的后台主程来公司已经14年了。为人谦逊，经验丰富，而且热爱写代码。 在这里历
练了很多。新项目需要在游戏内做一个空间系统，刚好我以前
在qq空间待过。知道业务上要如何规划，实现功能。老大也给予
了很大的信任空间，只是在方向上做一些把控，其余实现设计都
让我和另外一个同事来。两个人做了大半年，成品出来之后成就感满满，算是自己工作第四
个年头来独立负责的最大的模块。也完整的经历了系统从无到有
一系列的迭代过程。老大时常叮嘱我要把这个过程记录下来。
每个方案的迭代修改背景，理由和决策细节。
这些以后都是珍贵的答辩点.</p>

<p>做系统设计和实现的过程中，深深感觉像个保姆，系统就是个娃。你需要关注的方面不少。</p>

<ul>
<li>系统实现需要关注后续功能的扩展性，抽象出公共调用层.方便代码维护。</li>
<li>需要关注系统安全。安全包括数据安全，传输通道安全，用户登录态验证等。</li>
<li>需要关注系统的容灾，架构设计上不允许单点。出现故障的时候如果做到容灾切换以及故障恢复</li>
<li>需要关注运维的便捷性，在进行特性发布的时候如果方便的灰度和回滚</li>
<li>需要关注系统的监控，包括系统通用指标（CPU、内存、网络）
业务接口监控（请求延时、接口访问量，成功失败率）业务进程级别监控（进程CPU占用、磁盘IO）</li>
<li>需要评估给周边系统带来的存储以及带宽压力。了解周边组件
的缺陷，进而扬长避短</li>
<li>需要关注系统的过载情况，如果进行过载保护，以及柔性服务演练</li>
</ul>


<p>以前一直认为架构设计画画图都是些形而上学的东西，自己做起来才发现每个点都要关注到
。设计和实施并非易事。</p>

<hr />

<p>很庆幸年初做的转岗决定，遇到一个好的团队以及好的项目纯靠运气和认识。当然自己做的
还不够. 还有很多需要继续深入研究的地方</p>

<hr />

<p>年初的时候，也恰逢洪兴社的外包项目准备结尾，3月初是最累的时候，每周996，周天还
要赶去和小伙伴一起赶艺酷的外包项目.每天都在工作，心理和身体
双重疲惫。真正交付完之后自己感冒了好几天。心理打定主意以后不想在做外包了。实在是
太累了。
当然做这个外包项目，慢慢的自己也以主人公的心态来对待方案设计。了解到了leancloud,
七牛云存储，七牛直播云以及第三方登录的各种细节，摸索了
各种后台运维的经验和细节。了解到了阿里云的各种网络安全保障策略。这些都给自己后来
做其他项目和答辩提供了很大的帮助。总体下来还是很感恩外包的那段际遇的，也算是第一
次和同学凑成在一起干成的第一单业务。</p>

<hr />

<p>17年上半年主旋律基本就是加班，老婆的肚子也越来越大了。
我时常回来她已经入睡。我告诉她说入睡早规律作息娃才能健康成长。当时和一个同事以及
小叔子合租在一起，我们住的是大主卧。好在同事理解，大家都还相处融洽。我有时候周天
会做顿好吃的犒劳下孕吐状态中的老婆，清淡饮食. 17年的清明，端午还有中秋
国庆都在加班，生生加出来了接近一个月的工资，加上外包的钱，减少了债务的压力</p>

<hr />

<p>7月中旬的时候，部门组织扫尾团建。出发前几天老爸一大早给我打电话，让我
回去一趟，大伯去世了。64岁就走了。过程中经历了治疗以及儿女凑钱的各种
不开心事，我爸作为亲弟也借了蛮多钱出去。感叹人生无常，最后一次见到他是
16年年初去家里祭神, 也算是第一次以近亲身份参与葬礼。 树欲静而风不止，子
欲养而亲不在。还是要好好珍惜与父辈在一起的日子</p>

<hr />

<p>8月下旬,深圳的台风季节，26号正临帕卡台风，27号凌晨台风刮得厉害。提前一天老婆
先到了港大深圳医院。老妈提前一周上来了。那天记得是周六，正常来说是要上班的。
周六一大早就请了15天陪产假了，迎接小猪妹的到来。老婆生娃还算顺利，只是住院期间
人很辛苦，真真一晚上娃醒来多次。护士怕小儿睡觉低血糖，通常半夜2点多过来叫醒
给哺乳. 我租了床睡过道上，医院的护理房是三个床位一间房子的。用布帘拉起来遮住。
我经常坐滴滴回家做好饭再把饭带到医院去，晚上很吵基本睡不下，我通常是护理晚上，
让我妈白天来替我的班。妈妈办了医院的食堂卡，饿了就去食堂打饭吃，顺便给老婆打
些粥喝。娃刚生出来眼睛都是闭着的，长得清秀。记得出院那天，天气不闷不热，老婆
心情也挺好，可以回自己家里修养，至少能环境舒服点。
回到家后老婆发了高烧，几天不退，刚开始没经验，后来才知道是泌乳热。请了通乳师
，价格十分高昂，但是只是缓解下，过几天人又难受了，去了医院医生也只是开了阿莫西林
，不敢给产妇下什么药。中间也是各种纠结，阿爸和阿妈略懂治疗这些疾病，但是老婆并不
信任，不用他们的方子，导致双方都不是很爽，夹在中间不是很好做人.做月子期间还是辛
苦阿妈一直在我加班的时候帮忙煮给老婆吃饭以及护理娃的洗澡洗衣服等事宜。老婆子坐月
子期间也是各种睡不好觉。夜里怕我加班太辛苦睡不好觉都是自己一个人爬起来给娃喂奶。
娃都是咬奶头不怎么吃奶的那种，没咬着就哭，上奶嘴都不顶用。通常要一哺乳就哺乳个两
小时。很不容易。幸好这小家伙越大越懂事，后来都能整夜休息不吵不闹，连蚊子都咬不醒
。很乖很乖。</p>

<hr />

<p>18年1月份老婆因为在创业公司的缘故,需要提前返岗结束产假，丈母娘和妈妈轮番上来深圳帮
忙照顾娃。阿妈身体比较虚在深圳这边还连着发烧感冒了一周，时常夜里睡不好。我们晚上
都自己带娃怕吵到她白天精力不好还要应付带娃很是辛苦。后面阿妈说自己还是适应不了
深圳带孙子的生活，让我自己想办法处理。当然这些都是后话了。</p>

<hr />

<p>今年3月份，我们把自家在深圳买的房子收回来了（之前出租给公司同事）.但是因为临近答
辩的缘故，我没法花额外的精力去装修，都是哺乳期的老婆还有阿妈带着阿妹妹来做的大扫
除。租客因为只身一人在深圳，走得匆忙，房间只是粗略打扫一下。我也不想为难人就没要
收别人的清洁费。直到答辩之后才慢慢替换掉房子的灯具，钥匙，拆掉坏掉的窗户罩，置换
空调等。</p>

<hr />

<p>以上都是17年的一些生活大事迹. 下面再说说答辩的事。这个关系到后面的涨薪，以及17年
最重要的目标。由于我做过观战以及空间系统，有两个答的点。最开始找不到北。因为公司
内部大部分系统都是在既有系统里挑一个缺陷点，再做方案比对，再甩出自己的方案，最后
给出数据说明方案的优越。而我是从无到有做这个系统，陈述上并不符合这个套路。而说观
战又太过于单薄。最开始在组内试讲的时候非常紧张，几次无语沉默，弄得非常尴尬
后面不断的摸索别人的套路，找到自己的感觉，把要讲的点罗列出来，把过程中需要讲述的
话都打到备注里，一字不落。二次组内试讲的时候非常流利（当然是念备注比较轻松）.
也抓着老婆试讲了几次。发现还是容易卡壳记不住。无法顺畅表达。所以放弃了直接讲改用
念备注的方式。
在这个过程中也发现了自己设计上不足的地方，或者想得不合理的地方。对自己的系统设计
能力有很大的帮助。
答辩那天我是第一个答的，设备出了问题我前天晚上过去看的时候就发现有问题，一大早过
来刚好见到一位帅气的小哥，让他帮忙调试下。自己因为提前过来，能够做到从容不迫。
那天答辩全程念备注，当然过程中也有结合现场说案例去做一些展开陈述。评委还算客气
在我答辩过程中并没有打断我。后面进入提问环节。我的优势在于大家都是游戏部门的，都
讲游戏，而我独讲空间问题，评委比较新鲜。也没问出多难的问题。而且由于准备了两个多
月，加上全套系统基本都是自己做的，每个点都知道怎么解答。因此评委大多数问题都能解
答。当然有的是我想不清楚乱答，他们也没继续深究下去。答的南辕北辙的地方不知道是他
们没听懂还是没兴趣追问下去。结束评语的时候主评委做了一番评论。我听完后觉得估计能
过，因为没有重大的缺陷，而是就目前系统未实现的地方提一些建设性的缺点而已。等到
3.25 leader终于告知通过了，心理的一块石头也落地了。工作4.6年的时候终于过了T3. 把
普通工程师变成了高级工程师。当然同届入腾讯的早都升3了，有的甚至这次答辩升3.2了，
买了豪车和房子，甚是羡慕. 当然每个人都有自己发展的路子，有快有慢。也算是完成了17
年的全年目标。</p>

<hr />

<p>18年过年的时候，把丈母娘借钱首付的钱全偿还了，和老婆梳理了下一年的目标.</p>

<ul>
<li>归于沉淀，多读书，提高自身的技术实力，为后面家庭的发展和个人的发展积蓄力量</li>
<li>娃健健康康，教会她健康快乐的成长</li>
<li>争取年底具备答辩3.2的能力，这个说起来比较虚，至少去答辩的时候不虚。要做到这
一点需要成为业务骨干</li>
<li>做一个千人用户量的产品。缓解中年危机带来的压力，有自己的用户。</li>
<li>博文高质量分享 6篇+,这个是我写到这里的时候给自己订立的额外目标</li>
<li>空间系统顺利上线，可以hold住游戏上线后的压力</li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>产品后台搭建总结.</title>
      <link href="http://192.168.73.128:4000/2017/05/25/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%BA%A7%E5%93%81%E7%B3%BB%E7%BB%9F%E5%AE%9E%E5%BD%95/"/>
      <pubDate>2017-05-25T00:00:00-05:00</pubDate>
      <author>ftom</author>
      <guid>http://192.168.73.128:4000/2017/05/25/快速搭建产品系统实录</guid>
      <content:encoded><![CDATA[<p>上次写博文应该是年初的时候，眨眼间2017已经过去半年了。 这半年来
换了新的游戏项目，996周末还要兼职搞一个外包产品的开发。身心俱疲。
好在缓过来了。不管是游戏项目本身还是做产品本身，都给自己带来了
许多锻炼和思考。最近空闲下来，把之前搭建外包产品系统经历的东西
和考虑点整理出来。方便以后做的时候有历史可参照，也方便其他人
参考交流，少踩点坑。</p>

<hr />

<p>我接手的项目需要用到群聊功能，消息推送，提醒功能。以及常规的请求应答
接口。预估目标用户量不超过10万。需要支持管理端，Android，iOS，以及网页端.
开发时间在半年内。账号体系方面需要支持微信，微博，qq主流社交账号直接登录
还要支持扫一扫登录。支持短信验证改密。由于项目涉及到金钱相关的操作，因此
安全方面也要重点考核.
下面来聊聊面对这样一个产品系统构建过程中的一些心得体会。</p>

<hr />

<h3>善用服务</h3>

<p>麻雀虽小五脏俱全。大多数人接触到的外包系统用户量几乎很少过百万的。由于涉及
金钱余额操作，因此安全性摆在第一位。此外，稳定性也很重要。我做产品一贯坚持
的原则是先可提供稳定持续的服务，可扩展性和性能摆在其他位置。由于时间紧，开发
效率也很重要。</p>

<ul>
<li>语言框架方面选择了php和ThinkPHP，适合扩展，尤其是ThinkPHP
作者后来开发的OnThink 基于该内容框架二次开发管理端速度非常快。</li>
</ul>


<p>基础服务，能用服务组件则尽量使用，避免花费时间在造轮子上</p>

<ul>
<li><p>群聊功能，推送功能使用了leancloud的群聊推送功能。
leancloud还有完备的账号体系，账号还支持使用第三方登录创建账户，
支持用户名和密码登录，支持短信验证码登录，甚至账号本身还支持ACL权限控制
所以app，网页的账号体系全部都交给了leancloud。</p></li>
<li><p>图床服务直接使用七牛云存储，申请下来非常简单。 图片上传是在管理端上传的。
OneThink的图片上传服务就封装了七牛的图片上传，只要稍微修改下配置
就能实现管理端直接上传图片到七牛云存储了，非常方便</p></li>
<li><p>服务器直接使用了阿里云的ECS服务器，在上面还可以购买云数据库，阿里云自动
帮你做了binlog的增量备份以及一日一次的总体备份。对于数据库还可以一键申请
从服务器，业务完全不需要关心读写分离，阿里云的agent会自动解析sql，根据sql
是读操作还是写操作将数据库请求分发到不同的db实例去</p></li>
</ul>


<hr />

<h3>善用工具</h3>

<p>好的工具可以极大的提高团队协作效率和开发效率。
笔者的开发团队分布在北上广，大家工作基本都是远程沟通。因此及需要好的协作工具</p>

<ul>
<li><p>代码托管我们选择了 <a href="https://coding.net/">coding</a>
这个平台。 在上面还可以拟定计划和里程碑
定期的梳理进度等。但是我们用的最多的还是coding提供的git代码托管功能。
以及文档托管。</p></li>
<li><p>协议接口文档我们使用了有道云笔记提供的markdown文档模式。采用<a href="http://wowubuntu.com/markdown/#list">markdown</a> 语法编辑
之后可以将接口返回的json格式非常简洁明了的展现出来。对于初期接口还没准备好
又要定义复杂的json结构类型。可以先使用<a href="http://www.bejson.com/jsoneditoronline/">json在线编辑器</a>
编辑json格式再使用<a href="http://www.bejson.com/">json在线格式化</a>
输出易于查看的json数据样式.由于一开始就定义好协议，前后台都可以
同时进行协作。而且因为直接沉淀到文档，减少了很多沟通成本</p></li>
<li><p>开发工具类就很多了，web开发中用的最爽的是postman，可以直接
模拟发送http post 请求包，随时随地观察回包情况.当然工具不止别人
封装好的工具。对于后台开发来说尤其是使用php开发。善于使用日志
输出，捕捉上下文也可以提高开发定位问题的效率.由于平常经常需要
给数据库灌入假数据进行测试，利用手工录入费时费力。这种重复劳动
也可以快速写个录入脚本自动录入数据。每一个优秀高效的程序员，也必定
是个善于偷懒的程序员.
另外开发php推荐使用phpstorm IDE，上手了开发效率还是可以的。</p></li>
<li><p>另外设计子系统实现方案的时候。最好根据业务需求抽象出数据的不同状态。
画出完备的状态流转图和协议交互时序图，也就是UML序列图
凡事想清楚了和需求方反复确认之后再动手。一般甲方在提需求的时候
通常只考虑正常情况，异常情况常常没有提及或者根本没考虑到。
在开发阶段如果再把异常分支考虑进来，往往导致返工，效率低下
对于UML序列图强烈推荐使用Astah Professional.序列图里头可以手写
接口，开发的时候直接参照画的序列图开发，避免自己犯错.</p></li>
</ul>


<hr />

<h3>避免过度设计</h3>

<p>我们最开始采用的是LAMP来搭建系统。有一个相对比较复杂的数据
检索接口需要扫表构建数据集给前台展示。因此当时还引入了redis来
cache 检索数据，再定期过期淘汰。事后证明这么做只是给自己添堵。
维护缓存数据是个不小的开发工作。而且容易带来数据一致性问题。
后面及时砍掉了缓存这块的逻辑，改为直接操作db。在只有几万用户
的体量下，直接操作mysql是完全可以满足业务需求的。如果满足不了
，就要看看是否是自己实现的有问题了</p>

<hr />

<h3>踩过的坑</h3>

<p>下面来聊一聊开发过程中遇到的一些其他人可能也会遇到的问题以及处理方法。</p>

<ol>
<li>https 设置问题</li>
</ol>


<p>站点和app需要设置https，是基于下面几点考虑：</p>

<ul>
<li>app和站点使用https加密传输数据，防止中间数据被窃取或者篡改</li>
<li>苹果提审要求，不支持https会导致提审失败</li>
<li>有https证书的站点会显示小绿锁，给用户安全提示。特别是对于涉及
有金额交易的站点，小绿锁的存在能够给用户一定的心理安慰</li>
</ul>


<p>笔者站点使用的https是在goaddy上申请的。申请证书的过程需要需要上传
服务器的SSL csr文件，填写域名，并且通过goaddy提供的方式验证对于域名的所有权，
成功之后会得到三个文件，两个crt和一个key文件.站点的https配置可以参照以下
文章操作<a href="http://www.cnblogs.com/chjbbs/p/5748369.html">https 配置</a>
配置完后可以使用<a href="https://www.sslshopper.com/ssl-checker.html">SSL Checker</a>
检查配置是否生效。之前我配置的过程中忘记添加根证书了。结果小绿锁
显示失败. 把其中一个crt文件A追加到另一个crt文件B中，再在配置里引用下B就解决了。</p>

<p>另外web站点在进入某些页面的时候，还遇到了https小绿锁突然失效的情况。
这是由于站点引用了一些非https的资源导致小绿锁显示失败。
这个问题在某些站点也能看到，例如斗鱼直播的某些页面.
这种情况并非只是不显示小绿锁, 当站点使用https的时候，如果引用了非https的资源，这样的页面分享到
qq，微信都会直接白屏，iOS会提示证书非安全。分享的体验会受到影响</p>

<p>针对上述这种情况。可以将web站点使用的js和css静态资源全部托管到七牛云存储上
配置CDN动态加速域名，将域名配置为https的。即使有老的资源已经上传，配置完https自
定义域名后，七牛原有上传的图片链接也会自动转换为自定义域名.
七牛巧妙的使用了CNAME的机制，将用户提供的自定义域名CNAME到自己分配给用户的图片域名
上面去。对于自定义域名的证书，七牛也提供了证书申请平台，申请完后证书自动关联
对应域名.弄起来非常方便。等到所有的资源都切成https之后，上述的小绿锁问题
和分享失败的问题都能够解决了。</p>

<p>2.开发过程中还遇到使用第三方登录leancloud账号系统遇到的问题。</p>

<p>相信很多项目在开发过程中，都要支持qq，微信，微博三大主流平台的
登录。网页上要支持微信，手机qq，微博客户端直接扫码登录。
手机上同样要支持呼起微信，qq，微博客户端直接授权登录。
这些leancloud都有很好的支持。简单说来就是授权给应用之后，应用
可以拿到用户的openid和access_token. 对于leancloud 来说，这些就是
用户名和密码了。通过使用openid检索leancloud的_User表，再验证access_token
是否有效。对的上就能返回用户的唯一ID和会话token。
我们的项目也不例外。但是后来发现，在申请微信和qq的时候，同一个开发者账号
申请到的web和移动端的appid和appkey是不一样的。</p>

<p>对于同一个产品的不同端（Android，iOS，web）微信和qq都认为是不同的应用。
所以通过不同端登录上来的用户拿到的openid都不一样，这就导致了对于同一个应用
。用户通过同一个微信号或者qq号，通过网页授权登录以及移动端授权登录登入的是不同
的号。这个体验肯定是没法接受的。正常应该是通过同一个账号，不管通过什么终端登入
都是同一个账号。</p>

<p>针对这种情况，微信和qq提供了一个UnionID的机制。也就是对于同一个申请账号申请的不
同应用。这些应用如果是同一个微信或者qq登入的，那么通过微信或者qq接口可以得到同一
个UnionID.可以在leancloud的User表里新建三个列，QQUid，WxUid.</p>

<p>举个例子:
假设用户最开始通过qq移动端登录应用。应用后台拿着授权得到的openid和token去查询
leancloud。如果没有leancloud此时会新建一个用户账号。应用同步qq用户的用户名和
头像信息。并且设置好UnionID.下次用户通过网页登录，只要先通过授权拿到的UnionID去
查询User表，查到之后可以直接通过leancloud返回的数据拿到qq移动端登录的时候用的
openid和token。拿着这些授权信息直接登录leancloud即可。但是这种方式需要设置
leancloud不对access_token进行有效性验证。否则qq移动端长久不登录应用。
leancloud上的access_token就长久得不到更新，一旦超过有效期后，检查不通过，通过
UnionID这种方式网页端就无法登录上了。这个是官方提供的做法，当然是以损失一定的
安全性为前提的。</p>

<p>眼尖的人也许发现我并没有提到微博。这是因为微博通过同一个开发者账号申请的不同应用
最后拿到的Uid是一致的，所以不存在上述微信和qq的问题</p>

<ol>
<li>IPV6问题。
苹果爸爸提审要求服务器支持ipv6访问。而国内产商因为安全等问题，是不支持
服务器ipv6设置得。因此需要自己打开，可以通过打ipv6隧道的方式来处理。具体不
赘述了。可以参照以下这篇文章：
<a href="http://www.cnblogs.com/vijayfly/p/6612771.html">阿里云服务器如何设置IPV6通过appstore的审核</a></li>
</ol>


<hr />

<p>当然使用服务总会有坑的。leancloud用户系统的设计根本没有考虑到多端登录态的问题
。如果项目要支持网页端用户登录态和Android，iOS各自的token有效期，对不起，
leancloud不支持，每一个账号只有一个sessionToken。要基于sessionToken设计不同端的
过期机制是不可能的。而且leancloud的sessionToken是不会过期的，需要业务自己去刷新
。基于leancloud的用户体系，只要sessionToken一泄露，基本上可以拿到用户的所有信息
。而且可以无障碍登录Android,iOS，网页端.业务侧需要针对sessionToken做一些过期保护
机制很难，因为一端设置过期刷新了sessionToken，会导致其他已经登录过的客户端提示会
话过期，需要重新登录，这种体验位于产品，对于用户来说是无法接受的。</p>

<p>另外leancloud 为了支持用户名和密码登录，他的User表里name用户名是全局唯一的。一旦使用name
来作为用户名称，并且第三方用户名称已经被占用了，leancloud会同步失败(头像，用户名)并且给你
生成一串随机值作为用户名称。因此做第三方登录千万不要用name这个字段作为用户名字。
最好在leancloud的User表里再添加WxName，QQName这些。通过哪个平台登录的就用哪个平
台的name。但是这样子客户端就得关心是哪个平台登录的了.而且leancloud本身提供了一些
SDK。如果SDK上使用了name来显示用户名称，改起来就很麻烦了。</p>

<hr />

<h3>服务器安全</h3>

<p>最后来聊一聊服务器安全部署的问题</p>

<p>第一次在测试机上搭建redis的时候为了方便直接root启用了redis服务。
而且没有设置密码。后面发现服务器被入侵了。被一个法国人hack整成了挖矿机。
无奈测试机CPU计算能力有限。挖矿机跑起来我们连SSH都登不上去。这才发现问题。</p>

<p>后面自己去网上搜索了入侵原理，仿照着入侵下别人。结果真的弄到了服务器
root的登录权限。这其中有北京的创业公司的服务器集群，也有一些中型企业的
IBM机子，连百度的机子也黑了进去。当然权当学习。黑过的机子都mail给别人
让别人修补了漏洞了。这里推荐一个扫描系统，可以扫出有redis漏洞的站点，看下
自己是否在单子上.没错，他就是<a href="https://www.zoomeye.org/">钟馗之眼</a>
。之后部署的时候就特别小心了。在这里罗列下一些自己认为比较重要的点：</p>

<ul>
<li>业务服务组件进程最好源码编译，运行在非root用户权限下，并且对运行用户权限
做下严格限定</li>
<li>SSH端口最好开在非22端口上</li>
<li>非必要服务可以直接关闭掉</li>
<li>关闭SQL一些操作权限，类似于drop表删表数据或者删数据库的。</li>
<li>限制root直接ssh登录</li>
<li>对于redis服务最好不要开在6379端口，并且设置redis密码。</li>
<li>严格校验是否有sql注入</li>
<li>另外要多关注下乌云提供的组件漏洞，定时的修复漏洞。</li>
<li>缩减history操作记录</li>
</ul>


<p>更详细的可以参照阿里云的<a href="https://yq.aliyun.com/articles/47328?spm=5176.100240.searchblog.8.4Zxap4">安全配置</a>。</p>

<hr />

<h3>服务可用</h3>

<p>最后再来聊聊服务的可用性保障。对于业务服务，为了避免单点。业务服务器最好
有两台服务器，通过nginx或者其他负载组件实现业务服务。这种并非是说用户量少就不需
要了。有时候进行系统升级或者为了查问题。可以先隔离出一台来定位处理问题。放少量请
求进来。另一台正常提供外网服务。如果只是单台提供服务，挂了可用性就很难保证了。
数据层使用阿里云提供的服务。阿里云提供的云RDS支持配置从服务器实现读写分离和一主
多从。在数据层做主从配置也是很有必要的。阿里云自动帮你做一天一个全备份和每分钟
binlog增量备份。这些都是服务可用性的一些保障措施。而且有一点做得挺好，自动帮你做
读写分离，业务不需要关心，他们搞了个agent自动识别sql是读写操作进行基于sql的分发
。当然服务可用也离不开高效率的告警机制，大厂有立体监控体系，自动监控服务器通用指
标，也有基于接口的监控，一旦出问题会第一时间发短信进行预警。作为外包产品要享受到
这种业务级别的监控还是有点奢侈的。我很看好leancloud，七牛这种服务化提供商。他们
的出现能够缩减产品开发的成本，但是还是有一些服务空白需要填补。相信未来，我们能够
更加高效率的专注业务，基础研发支持的组件也会越来越丰富。这块也是一块亟待补足的市
场。如果没人做的话以后自己也是可以拿来作为一份事业来做的</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>thinkphp框架适配修改.</title>
      <link href="http://192.168.73.128:4000/2017/01/29/ThinkPHP%E6%A1%86%E6%9E%B6%E9%80%82%E9%85%8D%E4%BF%AE%E6%94%B9%E8%AE%B0%E5%BD%95/"/>
      <pubDate>2017-01-29T00:00:00-06:00</pubDate>
      <author>ftom</author>
      <guid>http://192.168.73.128:4000/2017/01/29/ThinkPHP框架适配修改记录</guid>
      <content:encoded><![CDATA[<hr />

<p>最近项目需要使用php开发，php开发中比较流行的业务框架有Laravel, yii, CakePHP.
最后决定使用ThinkPhp的原因是上述三种并没有用过,为了支持国产就直接ThinkPHP
搞起了。裸用php同样可以完成业务开发。但是业务上涉及到两三位后台同学
一起开发项目，时间上也比较紧.因此有必要借助框架约束来统一后台开发行为，
另外可以方便借助框架提供的路由，安全配置，ORM等通用功能提高研发效率
本文讨论的ThinkPHP仅限于3.2版本.</p>

<hr />

<p>ThinkPHP的代码非常简洁，基本上对于拥有入门级别的php开发都能看得懂。
改起来相对方便。在业务开发过程中，笔者发现PHP中的某些地方并不能完全满足
项目开发的需求，因此在参照内部系统的基础上对框架代码进行了补充修改。
所做修改已经在线上顺利跑过了。下面把修改点罗列下，为以后的项目做下记录
和经验积累.</p>

<hr />

<h3>日志api的修整</h3>

<p>ThinkPHP 提供了Log::record()的方法，官方建议使用该方法来记录错误日志，
该方法会将日志写入到内存中，在请求结束的回调中执行写磁盘存文件或者db操作。
但是业务开发过程中，日志信息根据日志的产生来源分为以下四种：</p>

<ul>
<li>用户行为日志</li>
<li>业务系统日志</li>
<li>统计日志</li>
<li>服务器行为日志</li>
</ul>


<p>用户行为日志通常跟具体的用户ID关联在一起，用来描述用户行为产生的关联结果。
现网用户投诉信息大多数从该类型的日志加以筛选和跟踪.在游戏后台系统中
这类日志通常会专门存储起来方便请求关键上下文保存，叫做tlog
业务系统日志通常作为用户行为日志的补充，更多的是关联请求接口的行为。
通常可以记录业务系统各种异常或者错误情况
统计日志用于多种统计行为，类似于接口请求耗时，在线人数，访问人数等业务系统指标
服务器行为日志用于记录跟业务逻辑无关的日志行为，更多记录的是业务系统与
操作系统发生关联部分的日志信息。类似于进程的CPU占用，内存占用，共享内存占用，
进程重启，reload，升级等日志信息。</p>

<p>线上的日志系统最好兼顾以下几个点：</p>

<ol>
<li>最好日志系统可以做到支持上述日志的分类的打印，</li>
<li>日志信息打印的时候最好跟代码上下文关联起来方便问题定位,</li>
<li>日志信息最好能够打标签，像Android那样打个tag来区分某些日志信息</li>
<li>日志信息最好能够区分打印级别，做到可配置化</li>
</ol>


<p>ThinkPHP除了满足第四点外，并不支持其他三点。因此对日志api做了修改以支持
上述三点, 同时满足根据日志来源区分打印。下面贴主要代码:</p>

<p><figure class="highlight"><pre><code class="language-php" data-lang="php"><span></span>    <span class="o">&lt;?</span><span class="nx">php</span>
    <span class="k">function</span> <span class="nf">GET_CODE_INFO</span><span class="p">()</span>
    <span class="p">{</span><br/>
        <span class="nv">$debugInfo</span> <span class="o">=</span> <span class="nb">debug_backtrace</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$debugInfo</span><span class="p">))</span> <span class="p">{</span><br/>
            <span class="nv">$fileLocation</span> <span class="o">=</span> <span class="nv">$debugInfo</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;file&#39;</span><span class="p">];</span>
            <span class="nv">$fileName</span> <span class="o">=</span> <span class="nb">strrchr</span><span class="p">(</span><span class="nv">$fileLocation</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">);</span>
            <span class="k">return</span> <span class="nv">$fileName</span> <span class="o">.</span> <span class="s2">&quot;:&quot;</span> <span class="o">.</span>
                <span class="nv">$debugInfo</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;line&#39;</span><span class="p">]</span> <span class="o">.</span> <span class="s2">&quot; | &quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="sd">/<strong></span>
<span class="sd">     * SVR LOG define</span>
<span class="sd">     * @param [type] $msg [description]</span>
<span class="sd">     */</span>
    <span class="k">function</span> <span class="nf">SVRLOG_WARN</span><span class="p">(</span><span class="nv">$msg</span><span class="p">,</span> <span class="nv">$tag</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="p">{</span><br/>
        <span class="k">if</span> <span class="p">(</span><span class="k">empty</span><span class="p">(</span><span class="nv">$msg</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
        <span class="nx">Log</span><span class="o">::</span><span class="na">myRecord</span><span class="p">(</span><span class="s1">&#39;svr&#39;</span><span class="p">,</span> <span class="nx">GET_CODE_INFO</span><span class="p">()</span> <span class="o">.</span> <span class="nv">$msg</span><span class="p">,</span> <span class="nx">Log</span><span class="o">::</span><span class="na">WARN</span><span class="p">,</span> <span class="nv">$tag</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">function</span> <span class="nf">SVRLOG_ERR</span><span class="p">(</span><span class="nv">$msg</span><span class="p">,</span> <span class="nv">$tag</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="p">{</span><br/>
        <span class="k">if</span> <span class="p">(</span><span class="k">empty</span><span class="p">(</span><span class="nv">$msg</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
        <span class="nx">Log</span><span class="o">::</span><span class="na">myRecord</span><span class="p">(</span><span class="s1">&#39;svr&#39;</span><span class="p">,</span> <span class="nx">GET_CODE_INFO</span><span class="p">()</span> <span class="o">.</span> <span class="nv">$msg</span><span class="p">,</span> <span class="nx">Log</span><span class="o">::</span><span class="na">ERR</span><span class="p">,</span> <span class="nv">$tag</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="sd">/</strong></span>
<span class="sd">    * [USR LOG  define</span>
<span class="sd">    * @param [type] $msg [description]</span>
<span class="sd">    * @param [type] $tag [description]</span>
<span class="sd">    <em>/</span>
    <span class="k">function</span> <span class="nf">USRLOG_WARN</span><span class="p">(</span><span class="nv">$msg</span><span class="p">,</span> <span class="nv">$tag</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="p">{</span><br/>
        <span class="k">if</span> <span class="p">(</span><span class="k">empty</span><span class="p">(</span><span class="nv">$msg</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
        <span class="nx">Log</span><span class="o">::</span><span class="na">myRecord</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="nx">GET_CODE_INFO</span><span class="p">()</span> <span class="o">.</span> <span class="nv">$msg</span><span class="p">,</span> <span class="nx">Log</span><span class="o">::</span><span class="na">WARN</span><span class="p">,</span> <span class="nv">$tag</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">function</span> <span class="nf">USRLOG_ERR</span><span class="p">(</span><span class="nv">$msg</span><span class="p">,</span> <span class="nv">$tag</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="p">{</span><br/>
        <span class="k">if</span> <span class="p">(</span><span class="k">empty</span><span class="p">(</span><span class="nv">$msg</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
        <span class="nx">Log</span><span class="o">::</span><span class="na">myRecord</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="nx">GET_CODE_INFO</span><span class="p">()</span> <span class="o">.</span> <span class="nv">$msg</span><span class="p">,</span> <span class="nx">Log</span><span class="o">::</span><span class="na">ERR</span><span class="p">,</span> <span class="nv">$tag</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="sd">/**</span>
<span class="sd">    * [STATIS LOG  define</span>
<span class="sd">    * @param [type] $msg [description]</span>
<span class="sd">    * @param [type] $tag [description]</span>
<span class="sd">    </em>/</span>
    <span class="k">function</span> <span class="nf">STATISLOG_WARN</span><span class="p">(</span><span class="nv">$msg</span><span class="p">,</span> <span class="nv">$tag</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="p">{</span><br/>
        <span class="k">if</span> <span class="p">(</span><span class="k">empty</span><span class="p">(</span><span class="nv">$msg</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
        <span class="nx">Log</span><span class="o">::</span><span class="na">myRecord</span><span class="p">(</span><span class="s1">&#39;statis&#39;</span><span class="p">,</span> <span class="nx">GET_CODE_INFO</span><span class="p">()</span> <span class="o">.</span> <span class="nv">$msg</span><span class="p">,</span> <span class="nx">Log</span><span class="o">::</span><span class="na">WARN</span><span class="p">,</span> <span class="nv">$tag</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">function</span> <span class="nf">STATISLOG_ERR</span><span class="p">(</span><span class="nv">$msg</span><span class="p">,</span> <span class="nv">$tag</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="p">{</span><br/>
        <span class="k">if</span> <span class="p">(</span><span class="k">empty</span><span class="p">(</span><span class="nv">$msg</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
        <span class="nx">Log</span><span class="o">::</span><span class="na">myRecord</span><span class="p">(</span><span class="s1">&#39;statis&#39;</span><span class="p">,</span> <span class="nx">GET_CODE_INFO</span><span class="p">()</span> <span class="o">.</span> <span class="nv">$msg</span><span class="p">,</span> <span class="nx">Log</span><span class="o">::</span><span class="na">ERR</span><span class="p">,</span> <span class="nv">$tag</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cp">?&gt;</span><span class="x"></span></code></pre></figure></p>

<hr />

<p>上述代码提供了统计日志，服务器日志，以及用户日志的调用接口.
在record实现的基础上增加了日志打印与代码位置的关联信息，
日志来源信息（svr, user, statis）。同时支持用户输入tag
下面来看看myRecord部分的修改</p>

<p><figure class="highlight"><pre><code class="language-php" data-lang="php"><span></span>    <span class="o">&lt;?</span><span class="nx">php</span>
    <span class="sd">/<em>*</span>
<span class="sd">     * [myRecord 自定义日志记录]</span>
<span class="sd">     * @param  [type] $message [description]</span>
<span class="sd">     * @param  [type] $level   [description]</span>
<span class="sd">     * @param  [type] $tag     [description]</span>
<span class="sd">     * @param  [type] $record  [description]</span>
<span class="sd">     * @return [type]          [description]</span>
<span class="sd">     </em>/</span>
    <span class="k">static</span> <span class="k">function</span> <span class="nf">myRecord</span><span class="p">(</span><span class="nv">$type</span><span class="p">,</span> <span class="nv">$message</span><span class="p">,</span> <span class="nv">$level</span><span class="o">=</span><span class="nx">self</span><span class="o">::</span><span class="na">ERR</span><span class="p">,</span> <span class="nv">$tag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nv">$record</span><span class="o">=</span><span class="nx">fasle</span><span class="p">)</span>
    <span class="p">{</span><br/>
        <span class="k">switch</span><span class="p">(</span><span class="nv">$type</span><span class="p">)</span>
        <span class="p">{</span><br/>
            <span class="k">case</span> <span class="s1">&#39;user&#39;</span><span class="o">:</span>
                <span class="p">{</span><br/>
                    <span class="k">if</span><span class="p">(</span><span class="nv">$record</span> <span class="o">||</span> <span class="k">false</span> <span class="o">!==</span> <span class="nb">strpos</span><span class="p">(</span><span class="nx">C</span><span class="p">(</span><span class="s1">&#39;USR_LOG_LEVEL&#39;</span><span class="p">),</span><span class="nv">$level</span><span class="p">))</span>
                    <span class="p">{</span><br/>
                        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="k">empty</span><span class="p">(</span><span class="nv">$tag</span><span class="p">))</span> <span class="nx">self</span><span class="o">::</span><span class="nv">$userLog</span><span class="p">[]</span> <span class="o">=</span> <span class="s2">&quot;[{ </span><span class="si">$tag</span><span class="s2">}] [{ </span><span class="si">$level</span><span class="s2">}]: { </span><span class="si">$message</span><span class="s2">}</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">;</span>
                        <span class="k">else</span> <span class="nx">self</span><span class="o">::</span><span class="nv">$userLog</span><span class="p">[]</span> <span class="o">=</span> <span class="s2">&quot;[{ </span><span class="si">$level</span><span class="s2">}]: { </span><span class="si">$message</span><span class="s2">}</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="k">case</span> <span class="s1">&#39;svr&#39;</span><span class="o">:</span>
                <span class="p">{</span><br/>
                    <span class="k">if</span><span class="p">(</span><span class="nv">$record</span> <span class="o">||</span> <span class="k">false</span> <span class="o">!==</span> <span class="nb">strpos</span><span class="p">(</span><span class="nx">C</span><span class="p">(</span><span class="s1">&#39;SVR_LOG_LEVEL&#39;</span><span class="p">),</span><span class="nv">$level</span><span class="p">))</span> <span class="p">{</span><br/>
                        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="k">empty</span><span class="p">(</span><span class="nv">$tag</span><span class="p">))</span>
                            <span class="nx">self</span><span class="o">::</span><span class="nv">$svrLog</span><span class="p">[]</span> <span class="o">=</span> <span class="s2">&quot;[{ </span><span class="si">$tag</span><span class="s2">}] [{ </span><span class="si">$level</span><span class="s2">}]: { </span><span class="si">$message</span><span class="s2">}</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">;</span>
                        <span class="k">else</span>
                            <span class="nx">self</span><span class="o">::</span><span class="nv">$svrLog</span><span class="p">[]</span> <span class="o">=</span> <span class="s2">&quot;{ </span><span class="si">$level</span><span class="s2">}: { </span><span class="si">$message</span><span class="s2">}</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="k">case</span> <span class="s1">&#39;statis&#39;</span><span class="o">:</span>
                <span class="p">{</span><br/>
                    <span class="k">if</span><span class="p">(</span><span class="nv">$record</span> <span class="o">||</span> <span class="k">false</span> <span class="o">!==</span> <span class="nb">strpos</span><span class="p">(</span><span class="nx">C</span><span class="p">(</span><span class="s1">&#39;STATIS_LOG_LEVEL&#39;</span><span class="p">),</span><span class="nv">$level</span><span class="p">))</span> <span class="p">{</span><br/>
                        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="k">empty</span><span class="p">(</span><span class="nv">$tag</span><span class="p">))</span> <span class="nx">self</span><span class="o">::</span><span class="nv">$statisLog</span><span class="p">[]</span> <span class="o">=</span> <span class="s2">&quot;[{ </span><span class="si">$tag</span><span class="s2">}] [{ </span><span class="si">$level</span><span class="s2">}]: { </span><span class="si">$message</span><span class="s2">}</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">;</span>
                        <span class="k">else</span>
                            <span class="nx">self</span><span class="o">::</span><span class="nv">$statisLog</span><span class="p">[]</span> <span class="o">=</span> <span class="s2">&quot;[{ </span><span class="si">$level</span><span class="s2">}]: { </span><span class="si">$message</span><span class="s2">}</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cp">?&gt;</span><span class="x"></span></code></pre></figure></p>

<hr />

<p>上述修改主要是把日志信息根据日志来源存储到对应的内存结构中，根据日志级别拼接
级别和tag.日志信息msg在传入的时候就已经拼接了打印日志时所在的代码文件和位置了.
当然打印日志时的代码位置信息为了调用接口的便利性直接从堆栈里取得，这里是否有性能
上的问题还需要做进一步的观察处理
ThinkPHP在请求执行完后会回调Log::save接口，只要在save接口里对上述的内存日志
结构做下判断，有数据就存到不同的日志文件里即可。</p>

<p>业务逻辑在打印日志的时候，只要类似于下面这样调用，就能获得足够的日志信息</p>

<p><figure class="highlight"><pre><code class="language-php" data-lang="php"><span></span>    <span class="o">&lt;?</span><span class="nx">php</span>
    <span class="nx">SVRLOG_ERR</span><span class="p">(</span><span class="s1">&#39;auction status[online-&gt;onsale], auctionId： &#39;</span> <span class="o">.</span> <span class="nv">$auction</span><span class="p">[</span><span class="s1">&#39;auction_id&#39;</span><span class="p">],</span> <span class="s1">&#39;auction&#39;</span><span class="p">);</span>
    <span class="cp">?&gt;</span><span class="x"></span></code></pre></figure></p>

<p>打印日志结果如下所示：</p>

<pre><code>[ 2017-01-28 21:59:17 ] 180.153.201.79
/yiku/JDOnline/Home/order/getLotOrders?userId%253D587799808d
226 ERR: /common.php:32 | errno[-100] errmsg[input error ]
</code></pre>

<hr />

<h3>业务代码层级调整</h3>

<p>ThinkPHP中提供了MVC模型.我们的项目主要提供rest api，因此用不到V层。
ThinkPHP中Model主要负责封装db操作，与DB发生交互。ORM的工作也在Model中
做了，操作DB很方便，而Controller主要处理业务逻辑。在项目复杂度，项目规模
不大的情况下可以将所有的业务逻辑都写在Controller里.
但是项目规模大了之后这种方式就不好使了。因此需要独立出来一个Service层专门
处理业务逻辑，Controller 专门负责业务请求转发和简单的数据操作。
这种代码层级规划的好处有以下几点：</p>

<ul>
<li>流转结构清晰，Controller里获取Service的处理句柄，调用Service里的方法并获取
结果，根据返回结果再决定下一步执行流程，不涉及具体的实现细节。方便开发团队
在Controller里就能获得请求流转的主脉络</li>
<li>提高代码复用度。Service负责实际的数据处理.项目主调除了普通用户，可能还来自
内部管理系统，以及网页端。面对各种端在独立出各自的消息路由层的时候，可以方便
的组合Service的调用来完成接口的调用。将实现独立出来一层而不是与消息路由杂糅在
一起，提高了代码的复用。降低了耦合度</li>
</ul>


<hr />

<p>框架上补充了Service的基类，要实现Service的时候只要继承基类即可。
目前基类提供的基础能力是根据子类里配置的过滤字段数组自动过滤敏感字段。
这点在所有接口里几乎都要被用到
下面是Service的基类实现</p>

<p><figure class="highlight"><pre><code class="language-php" data-lang="php"><span></span>    <span class="o">&lt;?</span><span class="nx">php</span>
    <span class="k">class</span> <span class="nc">Service</span>
    <span class="p">{</span><br/>
        <span class="k">protected</span> <span class="nv">$dataFilterOption</span> <span class="o">=</span> <span class="k">array</span><span class="p">();</span>
        <span class="k">public</span> <span class="k">function</span> <span class="nf">dataFilter</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">$data</span><span class="p">){</span><br/>
          <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="k">empty</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">dataFilterOption</span><span class="p">)){</span><br/>
            <span class="k">foreach</span><span class="p">(</span><span class="nv">$data</span> <span class="k">as</span> <span class="nv">$key</span><span class="o">=&gt;</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span><br/>
                <span class="k">if</span><span class="p">(</span><span class="nb">is_array</span><span class="p">(</span><span class="nv">$value</span><span class="p">))</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">dataFilter</span><span class="p">(</span><span class="nv">$data</span><span class="p">[</span><span class="nv">$key</span><span class="p">]);</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nb">is_numeric</span><span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">in_array</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">dataFilterOption</span><span class="p">))</span> <span class="nb">unset</span><span class="p">(</span><span class="nv">$data</span><span class="p">[</span><span class="nv">$key</span><span class="p">]);</span>
            <span class="p">}</span>
          <span class="p">}</span>
            <span class="k">return</span> <span class="nv">$data</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="cp">?&gt;</span><span class="x"></span></code></pre></figure></p>

<hr />

<p>使用的时候只要在子类的dataFilterOption 数组里配置需要过滤的db敏感字段
Controller回包的时候调用dataFilter即可
获取Service处理对象的时候要易于使用，笔者独立了一个Util文件夹，以单例的模式
来获取Service的对象.废话不多说了上代码：</p>

<p><figure class="highlight"><pre><code class="language-php" data-lang="php"><span></span>    <span class="o">&lt;?</span><span class="nx">php</span>
    <span class="k">namespace</span> <span class="nx">Home\Util</span><span class="p">;</span>
    <span class="k">use</span> <span class="nx">Tink\Log</span><span class="p">;</span>
    <span class="k">use</span> <span class="nx">Home\Services</span><span class="p">;</span>
    <span class="k">class</span> <span class="nc">ServiceUtil</span><span class="p">{</span><br/>
        <span class="sd">/<em>*</span>
<span class="sd">         * 取得Service类实例</span>
<span class="sd">         * @static</span>
<span class="sd">         * @param   $[name] [&lt;service名字&gt;]</span>
<span class="sd">         * @access public</span>
<span class="sd">         * @return mixed</span>
<span class="sd">         </em>/</span>
        <span class="k">static</span> <span class="k">function</span> <span class="nf">getInstance</span><span class="p">(</span><span class="nv">$name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="p">{</span><br/>
                <span class="k">static</span> <span class="nv">$<em>instance</span> <span class="o">=</span>  <span class="k">array</span><span class="p">();</span>
                <span class="nv">$service_name</span> <span class="o">=</span>  <span class="nv">$name</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$</em>instance</span><span class="p">[</span><span class="nv">$service_name</span><span class="p">])){</span><br/>
                    <span class="nv">$class</span> <span class="o">=</span> <span class="s1">&#39;Home\Services\&#39;</span><span class="o">.</span><span class="nv">$service_name</span><span class="p">;</span>
                    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nb">class_exists</span><span class="p">(</span><span class="nv">$class</span><span class="p">,</span><span class="k">false</span><span class="p">)){</span><br/>
                        <span class="nv">$obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nv">$class</span><span class="p">();</span>
                        <span class="nv">$<em>instance</span><span class="p">[</span><span class="nv">$service_name</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$obj</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">else</span>
                    <span class="p">{</span><br/>
                        <span class="nx">\Think\Log</span><span class="o">::</span><span class="na">record</span><span class="p">(</span><span class="s1">&#39;service instance not exists&#39;</span><span class="o">.</span><span class="nv">$service_name</span><span class="p">,</span><span class="s1">&#39;ERR&#39;</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="nv">$</em>instance</span><span class="p">[</span><span class="nv">$service_name</span><span class="p">];</span>
            <span class="p">}</span>
    <span class="p">};</span>
    <span class="cp">?&gt;</span><span class="x"></span></code></pre></figure></p>

<p>获取Service子类实例的时候只要输入Service类名字就可以获得实例了</p>

<p><figure class="highlight"><pre><code class="language-php" data-lang="php"><span></span>    <span class="o">&lt;?</span><span class="nx">php</span>
    <span class="nv">$handler</span> <span class="o">=</span> <span class="nx">ServiceUtil</span><span class="o">::</span><span class="na">getInstance</span><span class="p">(</span><span class="s2">&quot;AuctionService&quot;</span><span class="p">);</span>
    <span class="cp">?&gt;</span><span class="x"></span></code></pre></figure></p>

<p>这种处理方式方便业务逻辑开发的时候获取Service子类实例.
不过这种方式并不具备真正意义上的单例作用。意即减少Service对象的
创建.这跟php本身的生命周期管理有关系。
php作为一门web脚本语言。代码的生命周期只存在于单次的请求中。
php中定义的静态变量在请求结束之后就会被清理回收了。上述的单例模式
仅限于在单次请求中涉及多次对于同一个Service调用的时候减少该Service的
重复初始化。</p>

<hr />

<h3>错误码管理统一</h3>

<p>业务处理的时候，对于致命错误的处理采用抛出异常并在主干路径上
捕捉异常的处理方式。示例代码如下：</p>

<p><figure class="highlight"><pre><code class="language-php" data-lang="php"><span></span>    <span class="o">&lt;?</span><span class="nx">php</span>
    <span class="k">try</span> <span class="p">{</span><br/>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">init</span><span class="p">(</span><span class="nv">$userId</span><span class="p">,</span> <span class="nv">$auctionId</span><span class="p">,</span> <span class="nv">$lotId</span><span class="p">,</span> <span class="nv">$price</span><span class="p">,</span> <span class="nv">$username</span><span class="p">);</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">beforeBid</span><span class="p">();</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">doBid</span><span class="p">();</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">afterBid</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="nx">Exception</span> <span class="nv">$e</span><span class="p">)</span>
    <span class="p">{</span><br/>
       <span class="nx">deal_exception</span><span class="p">(</span><span class="nv">$e</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cp">?&gt;</span><span class="x"></span></code></pre></figure></p>

<p>通过上述方式避免了在关键路径上的嵌套调用过深的时候，需要层层返回错误
带来代码维护上的压力。这种抛异常的方式需要记住
抛出的原始位置在哪里。因此笔者重写了Exception的方法。Exception携带
一个常量描述的错误码，该错误码配置在一个专门的错误码文件里。通过
错误码可以在配置里查找到错误描述。Exception还可以携带外带的上下文信息
然后与配置里写死的错误描述拼接在一起返回给客户端并记录日志。
这些工作都在deal_exception里处理了。deal_exception还会获取到抛出异常时的
堆栈信息打印抛出异常的代码文件和位置到日志文件里头，方便快速查找异常抛出位置
错误码统一维护很有必要，避免了团队使用被占用的错误码，需要改错误描述的时候
只需要动配置就行了。通过统一配置的方式提高了代码的内聚性</p>

<p>下面贴下deal_exception的实现</p>

<p><figure class="highlight"><pre><code class="language-php" data-lang="php"><span></span>    <span class="o">&lt;?</span><span class="nx">php</span>
    <span class="k">function</span> <span class="nf">deal_exception</span><span class="p">(</span><span class="nv">$e</span><span class="p">){</span><br/>
        <span class="nv">$msg</span> <span class="o">=</span> <span class="nv">$e</span><span class="o">-&gt;</span><span class="na">getMessage</span><span class="p">();</span>
        <span class="nv">$trace</span> <span class="o">=</span> <span class="nv">$e</span><span class="o">-&gt;</span><span class="na">getTraceAsString</span><span class="p">();</span>
        <span class="nv">$errno</span> <span class="o">=</span> <span class="nv">$e</span><span class="o">-&gt;</span><span class="na">getErrno</span><span class="p">();</span>
        <span class="nx">Think\Log</span><span class="o">::</span><span class="na">record</span><span class="p">(</span><span class="nv">$trace</span><span class="p">,</span><span class="s1">&#39;ERR&#39;</span><span class="p">);</span>
        <span class="nx">reply_error</span><span class="p">(</span><span class="nv">$errno</span><span class="p">,</span> <span class="nv">$msg</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">function</span> <span class="nf">reply_error</span><span class="p">(</span><span class="nv">$err</span><span class="p">,</span> <span class="nv">$msg</span><span class="p">)</span>
    <span class="p">{</span><br/>
        <span class="nv">$config_msg</span> <span class="o">=</span> <span class="nx">C</span><span class="p">(</span><span class="nv">$err</span> <span class="o">.</span> <span class="s1">&#39;.ERRMSG&#39;</span><span class="p">);</span>
        <span class="nv">$err_msg</span> <span class="o">=</span> <span class="nb">isset</span><span class="p">(</span><span class="nv">$config_msg</span><span class="p">)</span> <span class="o">?</span> <span class="nv">$config_msg</span> <span class="o">.</span> <span class="s2">&quot; &quot;</span> <span class="o">.</span> <span class="nv">$msg</span> <span class="o">:</span> <span class="nv">$config_msg</span><span class="p">;</span>
        <span class="nv">$data</span> <span class="o">=</span> <span class="k">array</span><span class="p">();</span>
        <span class="nv">$data</span><span class="p">[</span><span class="s1">&#39;errno&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">C</span><span class="p">(</span><span class="nv">$err</span> <span class="o">.</span> <span class="s1">&#39;.ERRNO&#39;</span><span class="p">);</span>
        <span class="nv">$data</span><span class="p">[</span><span class="s1">&#39;errmsg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$err_msg</span><span class="p">;</span>
        <span class="nv">$log</span> <span class="o">=</span> <span class="nb">sprintf</span><span class="p">(</span><span class="s2">&quot;errno[%d] errmsg[%s]&quot;</span><span class="p">,</span> <span class="nv">$data</span><span class="p">[</span><span class="s1">&#39;errno&#39;</span><span class="p">],</span> <span class="nv">$data</span><span class="p">[</span><span class="s1">&#39;errmsg&#39;</span><span class="p">]);</span>
        <span class="nx">SVRLOG_ERR</span><span class="p">(</span><span class="nv">$log</span><span class="p">);</span>
        <span class="k">echo</span> <span class="nb">json_encode</span><span class="p">(</span><span class="nv">$data</span><span class="p">);</span>
        <span class="k">exit</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="cp">?&gt;</span><span class="x"></span></code></pre></figure></p>

<p>相关修整代码等项目开发完毕之后再附上链接</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2016年终总结.</title>
      <link href="http://192.168.73.128:4000/2017/01/26/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93_2016/"/>
      <pubDate>2017-01-26T00:00:00-06:00</pubDate>
      <author>ftom</author>
      <guid>http://192.168.73.128:4000/2017/01/26/年终总结_2016</guid>
      <content:encoded><![CDATA[<p>2016已经过去了，明儿就要过年了。过个几天2017也要
过去1/12了。时间就是这么快，年
末总免不了一番感慨。之所以没有选择在17年元旦做这篇
年终总结，是因为这一年经历了挺多事，不知道如何去梳理
。也算是喜忧虑参半一路走过来了.想到哪就写到哪吧。</p>

<hr />

<p>15年12月24号，赶着国家16年缩减婚期的档口赶紧和媳妇把
证领了。结束了长达一年的恋爱短跑。16年年初回家办酒了
走完当地的婚俗才算真正过门。
媳妇和我算是冥冥中注定的缘分。我们俩都是初四被父母押着
来相亲的，也都是第一次相亲。她和我都是同个高中物理班的,
只是高中时候我们谁都不认识谁。丈母娘曾经找过算命先生的
算过，说未来的女婿离家不远，人微胖也不高，老老实实一人。
那天相亲看到我就觉得：嗯这下子对上了。鬼晓得我也是大学
毕业后慢慢胖起来的。不过话说回来，媳妇性格挺好的，我们
都有互补的地方。所以2016年感到最幸运的事就是遇到了对的
人可以慢慢变老吧。</p>

<hr />

<p>15年年底的时候媳妇因为深圳报驾校考试周期长，给我老家报了
一教练，是她以前学车的教练，据说资历很老，是少有的负责任的
好教练。3月份的时候就被教练要求回去考科目一。从此开始了周末
不断的往返深圳普宁的路程。还好高铁方便，来回加上地铁倒腾在
路上的时间也就是6个小时而已。而且可以时不时回到家里见见爸妈，
慢慢的体会到媳妇的良苦用心。教练的集合点在丈母娘家附近，
每次返深，两位妈妈都备好各种好吃的家乡肉丸，排骨，粿条之类的
让我带上深圳吃.上班的早上经常能够动动手就吃到家乡的好吃的。
妈妈在我回深的时候总是让我带这带那，蔬菜水果瓜蔬。有的是亲自
叮嘱人订做的肉丸，有的是自家菜地种的青菜，还有自家产的牛奶之类的。
总恨不得我把整个冰箱都搬走。只是我比较愚笨，科目二练了20多次还是
考不过，学车周期也因为只有周末往返和中途高考生插队墨迹到了
年底。还在年底前过了科目三顺顺利的拿到驾照。完成了16年其中一个
小目标。
<img src="http://7xq3xt.com1.z0.glb.clouddn.com/xueche_changnei_20160424_051300.jpg" alt="驾照场内" /></p>

<hr />

<p>4月份回深的时候就想着要在深圳买个房子，一来到7月份来
来公司三年了刚好可以贷50万出来凑首付，二来还是觉得钱贬值
是个既定的事实，所以想尽快买个房子，以后有娃自住或者保值
都可以，也算是在大城市有个地方可以落脚.周末不回家学车的日子
开启了疯狂的看房之路。最开始的时候都是在知乎在百度上搜攻略
看过来人买房。联系的是链家，只是都是套路，刚开始差点出手买了
跟我年龄差不多的老旧楼梯房，只是卖家很强硬不愿意让价半分，
还让我干等2小时，索性不买，中介则是一直在撮合，最后房子成交了
比我当时的报价还高了6,7万.媳妇问是否后悔没拿下，我总觉得
没有缘分也不值得后悔不后悔的。作为买方出钱的是我没必要在
卖家面前装的跟个孙子求着买房.后面链家的中介给我留下了比较差
的印象。此处略去不表。在房网上机缘巧合认识了个中原的老牌地产中介
，老乡来的，对我蛮客气，办事也靠谱，经常从我们的角度考虑问题。
而且在提供靠谱服务的同时还是以最低的中介费用给我们办的.
后面我们差点以高于市场价出手泰华锦绣城的一套2楼鸡肋电梯房。
业主很屌不肯让价，说我这房子现在确实不值这个价，但是
你们要认同房价是会涨的，我要多拿未来要涨的这一部分，你们现在
不买以后这个价还真买不到。我们合算半天最后还说帮助我们只给降价
5万。那晚因为周五的缘故没有签，老婆一夜无眠，很是惶恐这个价格.
所以隔天早上我就直接回绝不签了.</p>

<hr />

<p>最后我们在宝安上车盘老城区里买了个电梯房子。看上的时候也没
纠结太多。因为看过太多盘了。个中优缺心理都有数，看中的当晚就
想和业主谈价签了。业主也算实诚，双方并没有议价，业主也是出的
小区盘同户型最低价了，五楼西南朝花园不吵，大户型实用面积高采光好
房子格局也还行。感谢各种机缘巧合最后能选中一套合适的。这个过程很是
艰辛，看中一套房到最后能够顺利以合适的价格成交，要做的功课实在太多，
运气也占据了很大成分.作为屌丝阶层做个决定就是要各种慎之又慎，可选范围并
不多，要侧重的因素太多了</p>

<hr />

<p>5月份的时候，岳父去了趟石家庄见亲兄弟，顺便想去北京走走，完成
自己多年的愿想。我在北京读了四年书，总体还是蛮熟的。于是媳妇要求我给当导游，
安排在北京2.5天 的行程。五一又是人员相对集中的地方.我直接订了天安门附近的
小旅店，住宿条件一般，但是离天安门城楼也就是十几分钟的脚程。去南锣鼓巷
和护国寺小吃店都非常近。几天的行程我们跑了北海，鸟巢和清华北邮。大多时候
都是到很晚才回去，鸟巢基本没什么人了，清净夜里别有另一番风景。由于有滴滴
的缘故出行非常方便。最惊艳的是去长城的时候，我们去到的时候以为要停止售票了。
结果售票员说现在才五点，6:30才停止，于是开心的直接上了南城墙,当时
天气偏冷,长城上人已经零零星星了，整个长城拍照的时候视野范围内都看不到游客
，别有一番长城萧瑟的滋味。 老丈人很满意我的安排，回去后一直夸奖。
当然很多时候都是刚好走运，各种巧合给赶上了，并非在我计划内.
行程中期还抽空跟毕业三年未见的老同学整了顿烤羊腿。见面的时候感觉大家都
褪去了稚嫩，开始变得成熟稳健了。
<img src="http://7xq3xt.com1.z0.glb.clouddn.com/P60502-181824.jpg" alt="长城" /></p>

<hr />

<p>八月份签订完购房合同，趁着项目组空闲的时间，想趁机休了2周的婚假 .老婆子的婚假15年底回去
办理婚姻安排，用掉了没法一起，这点挺对不起她的。刚好俊鸿从创业公司离职了，
于是两人商量一同来趟大西北自驾出游.出行拼了两杭州来的妹子，和一台湾大叔。
两妹子因为杭州G20 峰会的际会刚好有空出来玩，台湾大叔则是不愁生计的房东天南
海北到处去.这次西宁青海自驾游大大拓展了我眼界.我知道了青藏大草原的开阔，见识
到了平常只能在windows界面才能看到的大片草地，见识到了祖国聚宝盆柴达木盆地茶卡盐
湖的白茫与粗犷的光洁，我看到大片的牛羊点缀草海天际像
远方绽放的白色蒲公英。我吃到了青菜比牛羊肉还贵的饭店，顿顿牛羊肉不见腻歪的西北
特色美食，见识到了清真大寺的圣洁和湟光大批的回族大叔和漂亮妹子。我体验到了
旅行路上每天都是不一样的新鲜，以及人与人的信任和热情.当然西北行对自己也是
一种突破，因为从不曾一个人坐过飞机来到从未到过的陌生的地方，只能做足大量攻略
和检索来寻求行程的稳妥和安全感。路上最开始虽然天气不见好都是阴雨天，但是到达青海
湖西北地却多日晴天.这是行程中最幸运的地方。唯一缺憾的是驾照没拿到,路很好飙车却
没法开上租来的308s。下次自驾游该带着老婆孩子整个车队来了吧。
<img src="http://7xq3xt.com1.z0.glb.clouddn.com/P60830-101512.jpg" alt="草地" />
<img src="http://7xq3xt.com1.z0.glb.clouddn.com/P60828-193240.jpg" alt="美食" />
<img src="http://7xq3xt.com1.z0.glb.clouddn.com/zijia_P60831-112612.jpg" alt="小伙伴" />
<img src="http://7xq3xt.com1.z0.glb.clouddn.com/zijia_4210.JPG" alt="4120" /></p>

<hr />

<p>九月份走各种繁琐的买房手续流程，10月国庆的时候陪老妈回去了一趟桂林看
外公外婆和大外公大外婆。桂林我在小学五年级寒假的时候来过一次，已经有十几年没
来过了。在老妈的老家住了四五晚，乡下信号不好，跟清修差不多。每天做的事就是开着
小车带着外公和老妈，小表妹们去探亲，去山上捡柴火，去摘菜和水果.老妈子很开心。
我们在这里天天听着小桥流水，点着日光灯对着黝黑的大山听着外公吹牛。他年事已高，
用桂林话讲他过去的牛逼经历，我虽然听不懂，但是只要点头安静倾听就够了.老婆子
很喜欢这里的山野气息，早上喜欢早早拉着我在小乡村通往外面的水泥路上散步，两盘晨辉
斜染，给早秋的稻谷，半高的甘蔗，黄豆和绿树抹上一层金黄，加上露水的点缀一闪一闪，
这种山野的清新真心让人流连忘返。这次出行我第一次开车在路上走，还是很稳重的，
得到了大家的一致好评。这个还是要感谢教练的悉心教导，虽然没过科二，但是开起来已经
有自信和底气了。
<img src="http://7xq3xt.com1.z0.glb.clouddn.com/P61004-072013.jpg" alt="晨散步" />
<img src="http://7xq3xt.com1.z0.glb.clouddn.com/P61005-082050.jpg" alt="外公" /></p>

<hr />

<p>十一月份房子正式交接了，想着没钱装修，而且现在的房子也住的挺习惯的，所以想
把房子出租了，顺便做个良心房东。年底恰逢租房淡季，放了一个月没人来租，来看的
都没一个准信。随后降价500多主动在公司内部联系人，结果一看就订了.虽然房子偶尔有
些需要修修补补的，但是租客也挺好说话的，整租一家子刚有娃，需要处理什么我们也是尽快处理。
十一月份过了之后，老婆子有天突然告诉我怀孕了.这个消息来得相对突然。感觉这一年
结婚，买房，学车，生娃这些事全给整一年里了。如果这么说的话2016算是人生的幸运年了
。有缺憾的地方是年底背了个2星，被现任leader认为能力不足，技术热诚不够。
年底算是因为这些压抑了一把。但人生不可能十全十美，留点缺憾给2017解决。</p>

<hr />

<p>早上和老婆子一起梳理了16年的收入，老婆子是达到了16年的收入目标了，我只完成了
8成.根据现有收入能力评估了下，17年的目标有以下几个小点</p>

<ul>
<li>娃顺利健康的诞生。这个是最重要的</li>
<li>升3，提高技术实力成为项目骨干，要不娃都养不起了。</li>
<li>将欠款控制到某个阈值下。争取18年买车提上日程。</li>
</ul>


<hr />

<p>感谢2016所有的际遇， 2017 为了家人，为了生活继续奋斗！
付爸妈种的菜地,希望未来像这片菜地一样欣欣向荣，充满希望！
<img src="http://7xq3xt.com1.z0.glb.clouddn.com/IMG_20170126_145835.jpg" alt="菜地" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>话题聊配对系统方案设计</title>
      <link href="http://192.168.73.128:4000/2015/12/22/%E8%AF%9D%E9%A2%98%E8%81%8A%E9%85%8D%E5%AF%B9%E7%B3%BB%E7%BB%9F%E6%B5%85%E8%BF%B0/"/>
      <pubDate>2015-12-22T00:00:00-06:00</pubDate>
      <author>ftom</author>
      <guid>http://192.168.73.128:4000/2015/12/22/话题聊配对系统浅述</guid>
      <content:encoded><![CDATA[<hr />

<p>   去年年后接到一个独立系统，如下所示，需要根据某些话题为
两个不认识的人进行配对，配对上可以就该话题两个人交换意见聊天，
配对等待太久会结合用户属性出推荐话题。
大体样式如下图的两人牵线所示:
<img src="http://7xp7tl.com1.z0.glb.clouddn.com/subject.png" alt="话题" /></p>

<p><img src="http://7xp7tl.com1.z0.glb.clouddn.com/makepair.png" alt="发起配对" /></p>

<p><img src="http://7xp7tl.com1.z0.glb.clouddn.com/chat.png" alt="配对结束" /></p>

<hr />

<hr />

<p>什么？你逗我？这太简单吧？这玩意也能叫一个系统？
我后台开个进程，每个话题开一个队列。看下队列有人就匹配上，没人就入队列
等着别人来跟他匹配。分分钟给你搞出来！
那么问题来了。</p>

<ol>
<li>用户在等待配对过程得通知后台吧，切出话题不想配对了也得通知后台把
用户从话题的等待配对队列里剔除。但是逻辑层是多台机子无状态的，如果退
出话题的请求先于心跳请求到达后台。那么用户还是会插入等待队列中被其他
用户匹配上。这个时序问题如何处理？</li>
<li><p>匹配上了如何通知被匹配的一方?常规的通知是通过push下发，如果被配对的
对象刚好断网或者下线了呢？弱网络下如何保证基本体验？</p></li>
<li><p>系统估计1亿用户百万在线。每个话题分十万人，后台架构如何设计才能
支撑可能存在的扎堆请求配对的问题？</p></li>
<li><p>配对上的规则需要自由订制，例如男同女同话题只允许同性进入，暧昧话题
优先配对异性伙伴。星座话题优先配对相匹配星座伙伴，方案如何设计才能方便产品和运营需要？
。。。。。。</p></li>
</ol>


<p>上面的问题考虑过没？</p>

<hr />

<h4>下面先来聊下大概的一个方案设计问题。</h4>

<hr />

<p>前面陌生人群组的架构已经描述了整体的架构概况。而匹配服务
刚好是落在重型逻辑svr这一层。</p>

<p>最简单的方式是重型逻辑svr这一层做一个cache。然后每个话题建立一个队列。
每次配对请求到达的时候从cache中取出队列信息进行匹配。为了能在重启之后
快速恢复原来缓存中的信息，使用共享内存来管理cache。但是这种处理会带来
单点的问题。一旦匹配服务svr 挂机了就无法正常提供匹配服务。而我们做服务
的原则之一是保证成功率99.99% 以上。</p>

<p>因此需要在重型逻辑svr这一层加一个proxy。搞双机备份。但是关于cache的备份
又会带来数据同步的问题，是增量数据的时时同步，还是定时的同步。同步失败了
怎么处理？需要在proxy增加判定策略来判断服务是否可用。这套问题解决好了还有
新的问题。一旦匹配服务扛不住压力要扩容怎么办？很显然这套方案不利于平行扩展。
怎么降低这套东西的运维成本？这些是上面第一套方案需要面对的问题。</p>

<p>既然上面的方案对运维，扩容，以及版本升级的处理不是很友好，处理成本
相对较高。那我们来看看有什么优化的点。</p>

<p>之所以会出现上述问题，是因为逻辑层有状态，那将逻辑层处理成无状态，
状态保存在数据层。这样子可以直接使用基于内存的成熟数据库组件。但这种处理
方式会带来数据一致性问题。（分布式情况下访问相同的话题队列）。这种情况
需要怎么处理？遇到这种问题需要从业务数据模型出发。</p>

<p>按照以往产品得到的数据模型统计。从时间上分布同一个话题大概峰值是每秒1000
次配对操作。而db内网一次数据往返时延是10ms。运算下来出现数据冲突的概率在1%左右，
如果增加二次重试是0.01%（这里的估算是有问题的！）。因此把状态保存到db层这种
处理方式完全可以满足业务的需要。</p>

<hr />

<h4>重新再回到刚才聊到的话题</h4>

<hr />

<ol>
<li>配对时序问题。进入配对之后，每隔5s钟会有一次配对心跳到达。来确保用户还是
在当前页面等待配对。如下所示：如果A发起配对请求进入等待队列了，在心跳发出来
不久用户选择退出该话题配对了。客户端是采用请求入单队列的形式。请求从用户到
接入机还是有序的，但是请求从轻逻辑层开始就无法保证有序了。因此在处理配对请
求的时候，退出话题配对的请求到达，剔除等待用户。心跳请求稍后到达，又将本已经
退出话题的用户压入等待队列中。
最直观的体验是。我等了一会，没有等到配对对象，结果退出话题，一会客户端又显示配对上了。
具体情况如下所示：</li>
</ol>


<p>针对这种情况可以采用以下方案来处理。
配对请求本身包含以下过程：
发起请求配对，定时发起心跳表示还在等待，退出话题配对。</p>

<p>针对以上过程可以生成一个标记clientkey。这个clientkey可以使用用户名+时间戳+随机数生成。
在上述这组过程的请求都打上同一个clientkey。一旦退出话题配对，则在后台标记该clientkey
下的存储标志位，表示用户已经退出该话题了。如果接收到相同clientKey的心跳，就直接丢弃。
下次用户重新进入该话题，使用新生成的clientkey即可</p>

<p>具体数据结构表示如下：
处理方式：</p>

<p>后台维持一个key为clientkey，value为一个标志位的存储。客户端携带一个clientkey。
首次心跳到达后台会存储clientkey的值为0标志请求已经进入队列。取消操作会存储
clientkey的值为1标志取消操作。
（1）用户每次心跳上来都会查看clientkey存储的值是否为1，为1则直接丢弃心跳请求。
（说明用户已经取消这次配对了）为0则更新心跳时间。
clientkey会依照用户的操作场景累积起来，采用数据库自动淘汰方式淘汰即可。可以设置为1D
上述过程就变为如下图所示效果</p>

<ol>
<li>匹配上了如何通知被匹配的一方？常规的通知是通过push下发，如果被配对的对象刚好断网
或者下线了呢？弱网络下如何保证基本体验？
 目前Android在线push成功率大概在95%左右，在客户端收到客户端的回应包之后才会
认定为是收到push了。但是移动网络下面条件复杂，用户可能会出入电梯，可能在高铁上，
可能在干扰环境或者是基站覆盖信号较弱的地区，随时可能掉线。单纯靠push无法解决通知
到对方的问题。另外两人配对的时候，成功了，已有的解决方案是同时给双方发push，
会存在时序问题。一方A收到push，另一方B没有收到，那么另外一方会持续发心跳，
此时另外一方不在等待队列了。如果不将B重入队列，就会存在B一直等在配对过程页
的问题，除非push到达才能解决。如果将B重入队列，就会存在B同另外的人匹配上的情况。
从体验上来说是不合理的。</li>
</ol>


<p>针对这种情况可以采用消息推送+拉取的方式来处理。
配对成功后会在被匹配方clientkey下标记匹配对方等到用户下次重连之后在新
的心跳里可以直接获取到被匹配的对象。</p>

<p>处理方式：
因此后台增加了一个新逻辑。A和B配对上了，就从队列中剔除。同时将A，B的配对
信息存起来。扩充存到
clientkey：key：clientkey，value：bool
这个数据结构里即可，上述数据结构变为
clientkey：key：clientkey，value：bool，配对上的uid
每配对上一次，都要记两个clientkey的数据，clientkeyA和clientkeyB
每次用户的心跳信息上来后，都会预先查看自己的clientkey下是否已经有配对信息了。
如果有，则返回给用户配对信息。如果没有，则走正常逻辑。依靠push和拉取
两种方式保障push下的体验问题。</p>

<p>如下所示</p>

<p>被匹配上的B push虽然接收失败了，但是重新连上来之后带的还是断线之前用的clientkey。
发送的心跳到达后台查下clientkey下面已经有匹配信息了，本次匹配过程就正式结束了。</p>

<p>解决完上述的问题，原本简单的匹配过程变成了下述的流程</p>

<p>心跳主体流程图如下：</p>

<h4>正常心跳处理流程：</h4>

<p>用户首次进入话题和心跳都走同一个协议
1. 拉取用户个人资料
2. 拉取话题等待队列
3. 查看队列中是否有人在等待。根据用户条件做匹配。如果配对上则将匹配对象出队列，
通过push  svr 给双方发一个配对成功的push  请求。如果匹配不上则查看是否在队列中，
不在则将用户存入队列，在则更新心跳时间戳。匹配过程校验用户的心跳时间戳，
如果过时则将用户清出排队队列。</p>

<h4>退出话题流程：</h4>

<ol>
<li>拉取话题的等待队列</li>
<li>将用户从队列中剔除。</li>
<li>设置clienkey 下的bool值。</li>
<li>话题的等待人数减一</li>
</ol>


<h4>快速推荐流程：</h4>

<p>向用户推荐话题是在用户等待多次之后没有匹配上，在心跳返回包里给用户返回
可以快速匹配到人的话题。用户达到某个心跳阀值后后台会快速推荐流程。心跳计数放
在attachinfo里，根据终端透传回来的用户计数来触发快速推荐逻辑，快速推荐整体流程如下：
1. 拉取用户个人资料
2. 拉取所有的话题列表
3. 根据用户属性和话题属性筛选话题。
4. 后台会维持每个话题前一个小时和当前小时的配对成功计数。作为话题配对速率。
根据配对速率和当前队列的等待人数做加权排序，取前两个。如果匹配不上则返回空包。
给用户推荐的话题会缓存到终端上，同时会在心跳协议的attchinfo里带上标志数据，
下次心跳来了就不再走推荐逻辑了。心跳协议里有attach_info 字段，通过客户端透传，
加入心跳计数，推荐的话题标志位。下次后台拿到后根据心跳计数和是否已经有推荐话题
标志来决定是否走快速推荐的话题流程</p>

<h5>从这个独立系统里获得的收获是：</h5>

<ol>
<li>移动网络下如何结合网络情况最大化的保证用户体验的完整性和逻辑的统一。</li>
<li>需要在请求之间携带关联数据可以使用attch info 透传字段，类似于web的cookie 形式来记录一些关联数据</li>
<li>业务技术选型可以根据访问的数据模型来确定。不要一开始就把思维给定死了。</li>
</ol>


<hr />
]]></content:encoded>
    </item>
    
    <item>
      <title>陌生人群组项目架构浅述</title>
      <link href="http://192.168.73.128:4000/2015/12/15/%E9%99%8C%E7%94%9F%E4%BA%BA%E7%BE%A4%E7%BB%84%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E6%B5%85%E8%BF%B0/"/>
      <pubDate>2015-12-15T00:00:00-06:00</pubDate>
      <author>ftom</author>
      <guid>http://192.168.73.128:4000/2015/12/15/陌生人群组项目架构浅述</guid>
      <content:encoded><![CDATA[<p>去年还在做社交产品后台。过了不到半年原部门就被解散了，如今入职游戏已经半年有余了。
昨天跟一个技术总监闲聊，他问了我下过去都做过什么。摸摸脑袋竟然有好些细节都遗忘了。
趁着入职新项目组还有一周的交接时间，把过去的做过的服务挑出来。做下陈述总结。</p>

<hr />

<p>去年做过的服务是一个陌生人群聊的服务。主打兴趣社交，有群组聊天，有lbs 活动，
有话题速配聊天等服务。而我恰好都接触一些。 今天就先简单陈述下后台的整体架构和涉及到的一些细节.
服务器的设计和部署是冲着海量用户去的。在北京，上海，深圳三地都设置有接入点。处理后台集中部署在上海。
陈述前先细述下产品的策略架构。如下所示：
<img src="http://7xp7tl.com1.z0.glb.clouddn.com/%E5%BE%AE%E7%BE%A4%E7%BB%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%A7%E7%95%A5%E6%9E%B6%E6%9E%84.png" alt="群聊粗略架构" /></p>

<hr />

<h3>首次登陆处理流程是这样的：</h3>

<ol>
<li>客户端会写死一个域名。登陆的时候会访问域名所在的Mapping Server 映射服务器。
映射服务器会根据用户传上来的ip，网络运营商信息来给用户推荐最优接入的服务器ip列表
（统一接入网关的服务器ip）。这些最优接入的ip是由玩家跑马分析出来的，这里不做展开。</li>
<li>客户端在拿到最优接入ip之后，发起tcp连接操作。连接上统一网关之后。统一网关会将
用户请求转发给长连接服务器。</li>
<li>长连接服务器本地会做一些简单处理（黑名单用户过滤，鉴权）。鉴权通过之后会将请求转发给轻逻辑服务器。
轻逻辑服务这一层有多个服务器。转发给哪台服务器在长连接服务器这里会有一个决策逻辑，
当然这个决策逻辑最好是配置化的，具体算法由独立模块负责。（长连接服务器需要稳定少升级）
长连接服务器采用的libevent来管理网络连接。</li>
<li>轻逻辑服务器主要是做数据装配。各种版本兼容的擦屁股活。如果接口逻辑不重，
那么接口的实现也会做在这一层。时间久了代码看起来像一坨屎。这一层蛮要求编码规范约束和框架约束的，
否则到后面只想重构根本不想在上面继续迭代。轻逻辑层是面向用户最近的业务层，
通信上采用protocol  buffer协议，会负责请求各个api然后将客户端要求的数据组装起来返还给用户。</li>
<li>如果接口逻辑比较复杂，涉及到多模块的数据处理，这时候就会按照功能来划分模块。
每个模块负责实现独立特定的业务逻辑。这些业务逻辑属于重型svr这一层。为了避免不同业务之间相互干扰，
这一层不同功能模块的服务都是分开部署的。如果混合部署会出现各种相互干扰的问题。
（某些功能模块做了运营活动或是具有节日特征，会导致请求量激增。如果混合部署可能会导致其他模块拥有的计算资源被干扰，
一个稳健系统的一个重要条件就是柔性可用，某个模块有问题不会波及到其他模块）</li>
<li>数据层采用的是高速key/value 存储。如果部署在同一个园区内。从逻辑层到数据层的访问时延 一次往返在10ms内，基本可以满足业务的需要。</li>
</ol>


<hr />

<p>请求流向有两个：</p>

<ol>
<li>从长连接服务器->轻逻辑层服务->重逻辑服务<->db.常规请求类似于拉取个人资料，群资料会按照这个路径来走并原路返回</li>
<li>聊天消息会触发一个在线的推送处理。假设A用户在群里说了句话，由此引发的请求流向路径如下:
A用户接入机->轻逻辑层服务－>重逻辑服务层（聊天svr，做群聊计数修改，权限校验，敏感词检测，数据落地）
->push  svr(查找在线列表，获取用户接入的长连接服务器地址，组装推送包)->各个用户的接入机->到达终端</li>
</ol>


<hr />

<h3>以上架构中有几个细节需要提下:</h3>

<ol>
<li>轻逻辑层和重逻辑层不缓存任何用户数据，每个请求到来之后都是立马从数据库拉取最新数据进行处理。状态只保存在数据层。这种处理方式的好处是可以无障碍平行扩容。全程不需要开发介入，运维改改配置就能迅速增大系统的处理能力</li>
<li>第一点提到的逻辑处理层无状态会带来数据一致性的问题。对于一些共享数据访问可能会出现冲突的问题。但是社交应用不像银行系统需要高度的一致性。因此综合可维护性，性能采用了最终一致性的数据处理方式。处理数据的时候采用cas版本号校验。一旦出现冲突，让请求失败即可。这种失败的概率很小，对玩家体验造成的损失几乎可以忽略</li>
<li>为了提高系统的鲁棒性。层与层之间进行请求转发的时候必须摆脱对于物理地址的依赖。举个例子，轻逻辑层有多台服务器，重逻辑层也有多台服务器。但是轻逻辑层的服务器对后端的重逻辑层服务器发起一个网络请求的时候，只会选择一台。最简单的处理方式是维护一堆物理ip，每次负载均衡出一个ip。然后连接。这种方式最大的弊端就是后端服务器挂了会影响线上的请求。等到告警短信来了再手动刷配置下掉服务效率慢不说，也影响大家的日常作息。</li>
</ol>


<hr />

<h3>业界的经典处理方法如下:</h3>

<p>在主调和被调之间加一层proxy代理层。主调方只要无脑转发给proxy层就行。
Proxy这里会进行负载均衡 并会检测每个请求的错误情况。如果是非逻辑错误超过
一定阀值，或者定期发送给被调方的心跳没有及时 收到回包，就会告警并且自动将
被调方的故障服务器自动屏蔽一段时间，过段时间再重试下决策是否重新加入服务列表里。
<img src="http://7xp7tl.com1.z0.glb.clouddn.com/proxy.PNG" alt="代理转发" /></p>

<p>不过项目采用的是我见过的最优雅的处理方式。也就是上图架构中 的虚拟地址到物理地址的映射服务。
<img src="http://7xp7tl.com1.z0.glb.clouddn.com/L.PNG" alt="虚拟地址到物理地址转换服务" /></p>

<hr />

<h3>工作机理是：</h3>

<p>在每个服务器上维护一个agent。这个agengt负责接受映射中心推送过来的映射结果。
映射结果 是key=》ip，port。 主调方只要采用调用映射服务的api，传入key，
可以自动获取到ip，port。这个ip和port 是agent 计算出来的结果， 兼顾了负载均衡的逻辑。
每个请求调用结束之后都会上报业务错误码给agent，由agent 进行决策看是否是后端某个服务出故障了。
当然agent也会定期发送心跳给后端服务器。Agent得到的服务器检测结果会上报给映射中心。
映射中心再统一决策修改映射规则并下发给各个agent。以上处理方式把传统的proxy从通信链路里剥离出来。</p>

<hr />

<p>主调方采用滞后反馈的结果才连接后端，这种处理方式将负载均衡的功能处理成旁路逻辑。
提升了性能，而且后端的运维升级完全对前端来说事透明的。 当然有人会说以上的架构不就是接入层，
逻辑层，数据层这套东西吗。凭什么你这套架构就能够处理海量服务。但我想纠正一点
海量的服务体现在系统的各个细节处理上。而不是这些大概的层级划分。</p>

<hr />

<pre><code>从系统处理上，每一层都有精细化的处理。举几个简单的例子：
</code></pre>

<ol>
<li>在接入层这里会做最大连接数限制.</li>
<li>轻逻辑层这里的网络连接采用的是proxy，worker的处理模型。请求会以队列的形式进行排队处理。进队列的时候都会打上一个时间戳。如果超过队列缓存的最大个数，新来的请求会直接丢弃。如果从队列中获取到的请求等待时间过长也直接丢弃。</li>
<li>客户端这里也会谨慎重试。如果发现后端返回的错误码显示过载，会采用N步回退的重试策略，或者是出动画或者提示降低用户的焦躁感避免疯狂重试。</li>
<li>对于每个请求的成功，失败，返回码。时延，错误码分布，时间，qua这些维度的信息，都会在框架api里进行统一的封装上报。可以在监控平台里快速查询到接口在某个具体时间段的处理情况。如果超过一定阀值会进行短信，微信轰炸，第一时间通知到责任人</li>
<li>对于每台服务器都有流量，CPU，磁盘IO监控。对于每个涉及到用户关键数据的修改请求都有流水记录。方便出现问题的时候快速获取上下文处理。</li>
<li>对于功能相近的请求做抽象，进行并包处理。减少网络请求的耗时（国内跨地区的时延往返在100ms左右，不算上网络延迟堵塞这种情况）</li>
</ol>


<hr />

<h3>系统设计关键点：</h3>

<h4>1.用户在线列表是如何维护的</h4>

<p>上海深圳北京三地用户接入，都会设置用户的在线状态值。这个标记值存储在上海的db中，
同时存储接入机的ip和端口地址。此后，客户端会定期的发送心跳给接入机，接入机透传
给推送svr。这个心跳的间隔大概在5分钟到半小时不等。一旦推送svr在超过两个
心跳以上的时间间隔里没有收到客户端的心跳数据，就会认为是客户端掉线了。
这种情况下推送svr会设置db中的用户在线状态为 下线，同时清理纪录的接入机的
ip端口数据。用户群聊的时候会批量拉取群内用户的在线状态, 同时获取用户的接入机ip和端口，
除此之外还会读取最后一次刷新的心跳时间。 只有在线状态被标记
并且心跳时间的才会执行推送。以上对于用户的在线状态数据是由接入机进行通知维护的，一旦接入机挂机。就只能等
用户重连到新接入机再进行更新。所以，在线状态数据中还有一个辅助手段是用户的心跳时间，推送的时候一旦
判断到用户的最后一次心跳时间超时，也会设置用户下线并且不执行推送
设置这么长的一个心跳间隔也是有原因的。移动网络下用户可能会经历频繁的网络切换，
信号丢失等情况。预留足够的经验值时间来等待用户重连。目前这种机制推送的成功率在95%左右。</p>

<h4>2.用户在线列表是如何存储的</h4>

<p>用户在线列表存储在一个内存级的key，value 数据库中。用户可以选择用memcache，也可以用redis。做好备份，避免单点故障。</p>

<h4>3.前端接入机出故障会对用户有什么影响，如何处理可能出现的风险</h4>

<p>前端接入机是有状态的，一旦挂机，所有通过此接入机的用户都会掉线。这种情况下统一接入网关是有探测的。
会第一时间把故障机子下掉。用户重新登录接入该网关的时候，会自动将请求发送给其他接入机。从用户体验
上来说这种影响十分有限. 没有执行重新登录的用户，此时实质是在线不可达的。如果刚好有推送请求恰好读取了
用户过期的在线状态，并且还处于心跳时间间隔内。这种情况推送是会失败的。用户侧最直观的感受就是没有收到
推送的消息。作为辅助手段，在后台会存储用户的未读消息计数。等到下次玩家登录重连的时候会上传本地的已读消息
计数。通过比对之后再把没有拉取到的数据用主动拉取的形式进行同步</p>

<h4>4. 轻逻辑层，重逻辑层服务器挂机</h4>

<p>在这一层有虚拟地址映射的监测服务，如果请求失败超过一定阀值，会自动将故障服务器从可服务列表里除名。
会影响一些用户的部分请求。由于这些层的服务器无状态，下次请求的时候会使用正常的服务器来处理.对用户来
说几乎是无感知的。</p>

<h4>5. 数据层挂机</h4>

<p>数据层采用的是分布式的架构。实际服务的机器不止一台。分布式本身设计的核心理念就是容错处理</p>

<hr />

<p>以上处理方式适用于社交相关的应用。总体思想是先扛住再优化,架构上支持快速扩容,
柔性可用。在有限的资源支撑下快速应对随时会爆发的互联网海量请求服务。
写得太书面了，最近文笔退却好多争取以后写得幽默风趣点啊！</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>vim读书笔记</title>
      <link href="http://192.168.73.128:4000/2014/10/21/vim-read-book-note/"/>
      <pubDate>2014-10-21T00:00:00-05:00</pubDate>
      <author>ftom</author>
      <guid>http://192.168.73.128:4000/2014/10/21/vim-read-book-note</guid>
      <content:encoded><![CDATA[<hr />

<p>以前整理过vim的读书笔记，有本书是一位在读的印度学生写的， 写了些常用
的使用技巧，不像vim  用户手册那么大而全，非常适合用户自己
日常工作的使用，以下指令就可以高效完成90%的文本编辑工作了。
当然只是一些速记笔记，掌握vim的人可以时不时翻一下，以便回忆起一些
很久没用到有点生疏的指令</p>

<h3>跳转</h3>

<hr />

<pre>
<code>
Normal mode

:x   save working files and quit
:wq 
 ZZ 
 :qa   Exit all open files
 :version
 vimtutor
 [Ctrl] +  F
 [Ctrl]  + B
 [Ctrl]  + E
 [Ctrl]   +  Y

 jump :w  W  e  E  b B 
 {
 } 
 ( 
 )
 [[ 
 ]]

 H  M   L  (screen  jump)


 50% (Go to the 50th percentage of file)
 :50   (Go to the 50 th  line)
 50gg   (Another way to jump to 50 th line)


 [(  (Go to the previous unmatched (    )
 [])   (Go to the previous unmatched  )    )
 [{    (Go to the previous unmatched  {    })
 []}     (Go to the previous unmatched  )]]   )


 [Ctrl]  + O (jump back to previous spot)
 [Ctrl]   + I   (jump forward to next spot)


</pre>


<p></code></p>

<h3>搜索</h3>

<pre>
<code>
 vim +?search-term  filename   (Go to the first of the specified search term from bottom)
 vim +/search-term  filename   (Go to the frist of the specified search term from top)
 vim -t TAG  (Go to specific tag)


</pre>


<p></code></p>

<h3>打标记</h3>

<hr />

<pre>
<code>
 marks:
 ma
 `a
 'a
 :marks
 
 ma,mb,then  :'a,'bs/old/new/gc
 will display specific area  word
 
 
 
 `"  (To the position where you did last edit before exit)
 '.  (To the position of where the last change was made)
 
 
 
 ddp  dwp  
 

 :r!   COMMAND (Insert output of a command into current file after the current line)

 Insert Mode
 SHIFT + <Right  Arrow >  Go to right word -by-word  in insert mode
 SHIFT + <Right  Arrow >  Go to left word-by-word  in insert mode
 
 </code>
 </pre>


<h3>复制</h3>

<p> <code>
 <pre>
 copy line to the clipboard</p>

<p> :%y+
 :y+
 :N,My+</p>

<p> To copy the visual selected line to the clipboard,first visually select the
 lines, and :y+ which will apppear as :'&lt;,'>y+</p>

<p> here please check if your vim version support y+　register</p>

<p> write part of File to another File</p>

<p> visual mode selected save area,  then :
 :w newfilename</p>

<p> also you can do like this:
 :5,10w  newfilename</p>

<p> swap line or character</p>

<p> :xp   (swap character)
 :ddp  (swap line)</p>

<p> (dot)  usage:
 1. Search for a string in a file using: /zhihao
 2. Replace zhihao with wzhihao  using: cwwzhihao<Esc>
 3.Search for the next occurrence of zhihao:n
 4.Replace zhihao with wzhihao using:.(dot)</p>

<p> </code>
 </pre>
 ###正则处理
 <pre>
 <code>
 :g usage
 :g/^$/d  (delete all empty lines in the file)
 :g/^\s*$/d  (delete all  empty  and blank lines in the file)
 :g/pattern/d  (delete )
 :g/pattern/. w >> filename  (Extract line with specific pattern and
 write it into another file)(very userful!!!)
 :g/^/m0  (reverse a file)</p>

<p> :g/^\s<em>PATTERN\exe "norm! |/</em>\<ESC>A<em>/\<ESC>"  (Add a C style comment {/</em>text */} to all lines matching the pattern)
 (it can not work in gvim  yet,though it seems to be so useful  ~~~~)</p>

<p> Copy Lines to Named Buffer for Later Use
 valid named buffer: a to z (26 total valid named buffers)</p>

<p> "ayy
 "a5yy  (copied 5 lines to buffer "a")
 "ap  (Paste copied lines from buffer "a"  after the cursor)
 "aP  (Paste copied lines from buffer "a"   before the cursor)</p>

<p> </code>
 </pre></p>

<h3>头文件预定义</h3>

<p> <code>
 <pre>
 lowcase to uppercase,normally used in header file define
 visual mode
 select replace area
 U  (to upper case)
 u   (to lower case)</p>

<p> sort file content from vim as below
 :sort</p>

<p> sort selected content
 visual mode select specific area and add !sort at the end
 :'&lt;,'>!sort</p>

<p> :sort !  (descending order)
 :sort i (sort ignore case)
 :sort u (remove duplicate lines)</p>

<p> </code>
 </pre></p>

<h3>创建酷炫的文件注释</h3>

<p> <code>
 <pre>
 Extremely useful!  (78)</p>

<p> create a new *.c  file with automatic header</p>

<p> cat  c_header.txt
 :insert</p>

<p> /*-.-.-.-.-.-.--.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.</p>

<pre><code>     File  Name:

     Purpose:

     Creation Date:

     Last Modified:

     Created By :
</code></pre>

<p> -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.*/</p>

<p> add following lines in ~/.vimrc  file</p>

<p> autocmd bufnewfile <em>.c  so  /chriswei/c_header.txt
 autocmd bufnewfile </em>.c  exe "1," . 10 . "g/File  Name : .<em>/s//FileName : " .expand(%s)
 autocmd  bufnewfile </em>.c  exe "1,"  .10 . "g/Creation Date :.*/s//Cteation Date: " .strftime("%d-%m-%Y")</p>

<p>  autocmd Bufwritepre,filewritepre  <em>.c  execute "normal ma"
  autocmd  Bufwritepre ,filewritepre </em>.c exe "1," . 10.
  "g/Last Modified:.<em>/s/Last Modified:.</em>/Last Modified:" .strftime(%c)
  autocmd bufwritepost,filewritepost *.c execute "normal `a"</p>

<p> </code></p>

<h2> </pre></h2>

<p> <pre>
 <code>
  editor  color
  :syn on
  :syn off</p>

<p>  (extremely useful!)
  in vim Press K  on the word for which you want to read the man
  page
  K</p>

<p>  (extremely useful!)
  gd  (Go to the local declaration of a variable)</p>

<p>  gD (Go to the global declaration of a variable)</p>

<p>  (extremely useful)
  [Ctrl]  -  A  (incre Number)
  [Ctrl]  -  X   (Desc Number)</p>

<p>  (extremely useful!)
  to execute single Vim command  in insert mode</p>

<p>  [Ctrl]  +　Ｏ</p>

<p>  you are in insert mode typing characters
  Press  Ctrl - O ,which will terporarily take you to command mode
  do some vim command
  then you will automatically back in insert mode after the single vim commands is executed</p>

<p>  [Ctrl]  +  G  view file details</p>

<p>  </code>
  </pre></p>

<hr />

<p>  <code>
  <pre>
  gUU  change all the visual selected area to uppercase
  guu change all the visual selected area to lowercase</p>

<p>  execute any vim command when opening a file</p>

<p>  vim -c '<command   1>'  -c '<command 2>'  <filename></p>

<p>  skip loading plugins temporarily
  vim --noplugin filename.txt</p>

<p>  change color scheme</p>

<p>  :colorsheme  [color scheme]</p>

<p>  (extremely useful!)
  gf  (open a file whose names is currently under the cursor)</p>

<p>  </code>
  </pre></p>

<p>  ###vim加密文件</p>

<p>  <code>
  <pre>
  (safe   encrypt  extremely useful)
  :X</p>

<p>  unencrypt
  :set key =
  (to remove encrypt key)</p>

<p>  (extremely useful)
  save and resume vim sessions
  :mksession  filename</p>

<p>  vim -S filename</p>

<p>  </code></p>

<h2>  </pre></h2>

<p>  <code>
  <pre>
  (extremely useful)
  vimdiff  filename.txt  filename.txt.backup
  when diff window open
  [c  (Go to the next change inside vimdiff)
  ]c  (Go to the previous change inside vimdiff)</p>

<p>  Page 124 is Useful</p>

<p>  (extremely useful)
  :vimgrep search-pattern   filename.*
  (search for the search pattern inside all files ending  in .txt in the current directory)
  vimgrep by default will jump to the first file that contains a match,
  :cn (will jump to the next file)
  :clist    (view all files match the pattern)</p>

<p>  set vim as default editor as follow
  export EDITOR=vi</p>

<p>  view all changes done to a file after opening it
  :changes</p>

<p>  view ascii code of a charactor
  ga</p>

<p>  (extremely useful)
  vim -b  binaryfile (edit binary files in vim editor)</p>

<p>  </code>
  </pre></p>

<hr />

<pre>
<code>
  terrible  useful，release  your  mouse：
  paste  content  copy  by  yw  in  command line
  1.  “ayw   copy  the  search  content
  2. Ctrl-R  and  input  a    to paste the content
  detailed introduction  below:
  There are times when you're tempted to lift your hand from the keyboard 
  to the mouse, idly wondering if there's a better way. One such case is
  taking text from a buffer and placing it into Command-line mode. For example,
  performing text substitution with %s, or invoking a shell command with :!.
  Many Vim users will reach for the mouse and use the operating system's copy
  and paste feature to do this, but there's a quicker way provided by Vim's registers.

  The CTRL-R (:help i_CTRL-R) command can insert the contents of a register in Insert 
  or Replace mode. This is known as a "special key" (:help ins-special-keys). 
  The great thing about this shortcut is you can reuse it to put registers into
  Command-line mode. For example, let's say you've got some text you want to search 
  for in a buffer. First yank the text into a register, and then paste it with CTRL-R:
  In Normal mode, type "ayw to yank a wordPress escape, and then / to searchThen press
  CTRL-R and a to put register a
  A shorter way to do this is to use the default register. Typing yw will yank up
  to the word boundary into the default register, and then typing CTRL-R_" will put 
  it into the command-line. It's worth practicing using this, particularly if you 
  haven't got used to working with registers yet.
  
  (extremely useful!!!!!)
  folder code
  za (Toggle the fold under the cursor)
  zR (unfold all folds)
  zm (Fold everything back again)
  :set foldmethod = manual
  
  zf/pattern  (to fold lines selected by the search pattern)
  
  :range fold  (To fold lines specified by a range)
  :mkview (save all your folds as show above)
  
  :loadview
   

</code>
</pre>


<h3>推荐插件</h3>

<hr />

<pre>
<code>
   plugin

    ctags
    :ta main  (jump to the definition)
    :ta /^get   (jump to the match pattern)

    NERD  Tree  (specially useful)

    autocorrect.vim  (nice)

    (extremely userful!!!)
    Align.vim

    before align 
    a = 1
    hello world = 2
    sh = 3

    after align 
    a           =  1
    hello word  =  2
    sh          = 3 

    perform 
    visual  mode select align area and input
    :'<,'>Align = 

</code>
</pre>

]]></content:encoded>
    </item>
    
    <item>
      <title>类微博类产品mysql存储方案设计.</title>
      <link href="http://192.168.73.128:4000/2014/10/18/like-microblog-mysql-table-design/"/>
      <pubDate>2014-10-18T00:00:00-05:00</pubDate>
      <author>ftom</author>
      <guid>http://192.168.73.128:4000/2014/10/18/like-microblog-mysql-table-design</guid>
      <content:encoded><![CDATA[<hr />

<p>下午需求做完了，刚好其他同事在搞方案评审。做的是一个新的sns产品。所以去旁听了会。sns中涉及到好友动态查看，以及互粉关系链存储，评论这些功能。由于是节目订阅类， 产品的功能点有很多跟微博类似。之前使用公司的架构同样可以扛住海量用户的请求冲击。但是leader的想法是追求创业团队的小而美，快速迭代上线。用公司的框架太重了， 调用链路太长，开发和维护的成本都比较高。所以架构上采用了通用的lamp组件进行开发。问题来了，挖掘机哪家强.......哦，说错了，是mysql中的数据结构如何组织才能够支持 快速的查询和数据层的无障碍扩容。</p>

<hr />

<p>关系链中因为有关注，有粉丝，最简单粗暴的方式是把这些关系都存成一张表。表属性设置为fromid，toid，timestamp。fromid代表发起关注者的id，toid表示被关注对象的id。 我们暂时称这张表为A吧。如果要查一个人关注了谁，<pre><code>select toid from tablename where fromid=XXXX</code></pre>就行。如果要查一个人的粉丝是谁<pre><code>select fromid from tablename where toid=XXXX</code></pre>就可以检索出来</p>

<hr />

<p>这么搞真的行么？用户获取好友动态的时候，不管是采用推送模式还是拉取模式，都需要去查一把关系链。推送模式得查粉丝关系链，拉取模式得查关注关系链。 进一个人的主页查看对方关注列表或者粉丝列表需要知道这些列表中的账号与自己的互粉关系同样需要查询这张表。可以说关系链是访问最频繁的数据之一。 对于百万级注册用户，假设平均每个人关注了100个人，那这里的关系记录有100个百万也就是1亿条记录。对于检索频繁而且数据量这样大的数据，存到一个表里对于mysql的性能 是个问题。业界常用的做法是分库分表。分表也有垂直分表和水平分表这些方式。对于关系链存储，最适合的是水平分表。将数据打散到多个表中来减低访问的压力。 最简单的分表方式可以按照fromid来hash。业务侧或者中间层维护好映射关系。</p>

<h3>这里又带来了另一个问题：</h3>

<hr />

<p>数据分表之后。如果要查找某个人的粉丝列表<pre><code>select  fromid  from tablename  where toid=XXX（XXX是用户id）</code></pre>，需要对所有表都发起sql查询。假设分了N张表。 有M个查询粉丝列表的请求那这样产生的请求量就有M*N个sql请求。拿这样的系统出去都没法见人啊。说白了就是查反向关系链成本比较高。解决方法是再开一个冗余的关系数据表。 表结构跟A表一样，我们暂时称作B吧。但是分表的时候是根据toid来进行水平分区的。查反向关系链的时候可以根据toid映射到对应的表里快速查找到用户的粉丝列表。</p>

<h3>采用这种方式又带来新的问题：</h3>

<hr />

<p>用户的一次关注操作需要在表A和表B中塞一条记录。这里本身是一个事务操作。当然我们可以以A表的数据为主。B表数据只要保证最终一致，定时同步就行。</p>

<h3>这样的关系链存储是否就是最优的？</h3>

<hr />

<p>想得美啊骚年。遥想当年使用微博，知乎的时候，刚注册就给你推荐一坨人，运营和产品要搞个一键关注，一关注就是几十上百个人啊。 采用这种存储方式带来的问题就是关注多少人就产生多少sql语句啊。而且因为搞了A，B两张表，就是2倍的sql语句啊。虽然关注的写量不比发SNS里发动态的写量 ，但是这里的数据表膨胀速度还是蛮快的。尤其是有高质量的用户活跃的时候，关注写操作比较多，半夜都要起来分表啊，做数据迁移。写操作的成本和维护的成本都比较高。 是否有一种解决方案可以减少sql的执行次数，降低数据表膨胀的速度？毛主席教导我们，把别人的经验变成自己的，他的本事就大了。 qq空间老版本用的也是mysql。关系链存储存成两张表，一张是follow关注表，一张是粉丝表（这里简称为方案二）。表结构属性如下：uid，uidlist。 uid是用户的id，uidlist是关注对象或者粉丝列表，打包成二进制数据存成BLOB。</p>

<h3>采用这种方式，好处有以下几点：</h3>

<ol>
<li>原来一键关注多人的写操作可以整成一条语句，只要修改uidlist就行了。另外数据会更加紧凑。假设mysql存储采用B+树InnoDB 存储引擎，平均每人的关注和粉丝列表都是100人，采用Blob的方式B+树的宽度要比原来存到A，B表（这里简称为方案一）的宽度理论上小100倍。B+树的结点分裂也比方案一频率要小。在uidlist比较短的时候写入效率高。</li>
<li>检索效率高。只要检索到用户的id就可以把所有关注或者粉丝列表拉出来，而方案一由于是一条条记录，即使在fromid或者toid上建立索引。查找的时候需要拉出
一个或者多个区块的数据出来。</li>
</ol>


<hr />

<p>缺点：采用这种方式，当用户关注对象或者粉丝量大的时候，每次都要操作一坨数据。如果某个用户出现粉丝集聚的情况，每次更新该用户的数据的时候都要把整个粉丝list都拉出来， 再塞回去。如果uidlist里需要塞每个用户的操作时间戳，uid，就有8个字节。出现百万乃至千万个uid的时候每次拉取的数据会达到8M-80M。在删除的时候还要遍历这些uidlist再行删除。 判断用户是否在uidlist中也要做次百万千万级别的查找。为何空间适用的关系链存储就没问题。因为空间是熟人社交，没有粉丝名人的集聚效应。当然你会说不对啊， 小米的认证空间不就有上千万粉丝么。这里是因为认证空间采用的是B+树单纯存储这些关系链的，相当于又采用方案一的表结构来存储。没有哪种数据组织形式可以适用于一切情况。 业务侧个人的关注量很有限，但是粉丝数却有可能突破上百万上千万。我们可以采用混合方案的方式。对于粉丝数目超过百万的大户，我们可以采用方案一的结构来单独存储这些用户的粉丝关系链。
粉丝数目小于百万的，可以采用方案二来存储。方便数据的快速写入和读取。这种处理方式可以应对海量的关系链数据处理，但是无疑也相应的增加了业务逻辑的复杂性。但是相对于采用单纯的方案要好</p>

<hr />

<p>SNS中涉及到另外一个问题，好友动态如何快速的拉取。这里有pull和push两种方式。pull主要是采用拉取的方式。用户每发表一个好友动态，都会插入到一个动态表中，我们叫做feeds吧。feeds的表结构设置为 <pre><code>author，content，timestamp,extra msg</code></pre>每次拉取的时候需要</p>

<pre><code>select * from feeds where feeds.author in(关注列表)</code></pre>


<p>pull方案既要查询关系链，又要根据关系链去动态列表中过滤出关注对象的动态。做排序。检索的时候可以根据在增量feeds表中做数据检索。 这种方式实现简单，可以实现业务需求，但是操作时间复杂度达到O(M)*O(N),M是动态表中的记录长度，N是关注列表的长度。</p>

<hr />

<p>push方式是再设置一张表，我们叫做friendfeeds吧，表结构设置为uid，feedslist[{feedsid1 : timestamp1},{feedsid2:timestamp2}] ，uid是用户id，feedslist是关注对象发的feedslist列表。 列表按照发布时间进行排序。feedslist可以只存好友动态的id。如果用户取消了对关注对象的关注，顺带删除feedslist中关注取消对象的动态信息就行了。用户刷新动态的时候只要查friendfeeds， 拉出feedslist。如果feedslist中存储的是动态的全量数据，那么拉取好友动态的时间复杂度是O(1).但是如果出现粉丝集聚，热点账号发布一条动态会带来恐怖的写扩散。上千万用户会带来上千万的写操作。 而且带来大量的数据冗余。用户修改动态数据或者app需要修改展现格式的时候修改成本也很大。退一步feedslist只存feeds的索引，拉取到feedslist之后再根据索引去拉动态数据。所有动态数据只存一份。 这种方式带来的拉取时间复杂度是O（M）（M是feedslist的长度）要修改动态的展现形式或者用户需要修改自己发布的动态的时候都只要动一份数据就行了。 只是只存索引的方式同样还是没法应对粉丝集聚带来的恐怖写扩散问题，之前处理过的相关的业务，单单针对热点账号存的写索引数据成本很惊人。</p>

<hr />

<p>这里进一步做混合方案。push只针对热点用户，用户每次登陆的时候，都会去更新热点状态位，对于长时间没有登录的用户，热点状态位被重置。用户很长时间登录之后如果热点状态位没有被激活， 就用拉的方式去获取动态数据。另外如果查询到的热点状态位处于有效状态，则去friendfeeds表中拉取自己的好友动态。对于热点账号， 为了防止恐怖的写扩散,我们可以在friendfeeds数据表中加入新的属性如下：<pre><code>uid，content，feedslist[feedsid1,feedsid2....]，hotuidlist[uid1,uid2....]，timestamp</code></pre> feedslist存储的是关注人最近发布的动态id，按照发布时间排序。hotuidlist是自己关注的热门账户uid 列表。timestamp是用户上次拉取动作的时间戳。 另外有个hash表（简称动态时间hash）存储热点用户的最新的动态发表时间戳，最近一周内发布的动态的id和对应的时间戳，hash表结构表示为：</p>

<pre><code>key：uid
value：最新动态时间戳，[{feedsid1:timestamp1},{feedsid2:timestamp2}.........]</code></pre>


<p>每次热点用户发布新动态的时候都会去更新这张hash表的发表时间戳和id。用户在拉完friendfeeds   里普通关注人的feedslist之后，也会拉到关注的热点账号的uidlist和上次拉取的时间戳。 拿这个时间戳去动态时间hash表中比对下时间戳，如果不一致就根据时间戳过滤出hash表中的这些热门账号的feedsid，再把拿到的这些feedslist索引去feeds表中拉取真正的动态数据。 这样拉取动态的时间复杂度是O（M+N*T/2）M是feedslist长度，N是用户关注的热点账号，T是每个热点账号还未被用户拉取的动态数量。采用这种方案避免了push的写扩散， 相对pull先去查关系链再去遍历feeds表要快些，少了查关系链的sql操作。用户长时间没有登录，后台的定时任务可以重置热点状态，同时删除friendfeeds中关于用户的feedslist数据。 friendfeeds  和hash  这两个结构建议放在cache里，承载的组件可以用redis。</p>

<hr />

<p>当然，对于一个新业务，快速上线才是王道，怎么简单怎么做。当请求量大之后架构上可以支持快速加机器扛住请求。做复合优化方案不需要对存储做大的变动。 个人觉得就是好的方案。第一次发文，有错误的地方欢迎拍砖~</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
